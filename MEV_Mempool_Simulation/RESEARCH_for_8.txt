A Framework for Simulating Adversarial Economics in Blockchain MempoolsThis report presents a comprehensive framework for the simulation and analysis of Maximal Extractable Value (MEV) and the adversarial economics of blockchain transaction mempools. It is divided into two primary parts. Part I establishes the rigorous theoretical and mathematical underpinnings of the mempool, block-space auctions, and prevalent MEV strategies. Part II provides a complete, Colab-ready Python implementation of a simulation laboratory built upon these formal models, designed for reproducible experimentation and analysis of adversarial dynamics.Part I: Formal Models of Mempool and MEV DynamicsThis section establishes the complete theoretical underpinning of the simulation environment. The analysis proceeds from the micro-level dynamics of individual transactions to the meso-level mechanics of block construction and culminates in the macro-level strategic interactions of competing block builders. Each stage is defined with mathematical rigor to provide a robust foundation for the subsequent simulation.Section 1: The Mempool as a Dynamic Economic SystemThe environment where MEV opportunities arise and are contested is the transaction mempool, a dynamic waiting area for unconfirmed transactions. The economic value within this system is allocated through a complex interplay of transaction arrivals and block-space auctions. This section formalizes these core components, modeling the ingress of value and the mechanisms that price its inclusion and ordering within a block.1.1 Formalizing Transaction and Bundle ArrivalThe foundation of any mempool model is the arrival process of transactions. A critical distinction in the modern MEV landscape is the separation between publicly broadcast user transactions and privately routed searcher-builder bundles. This information asymmetry is a primary source of value extraction for sophisticated block builders and is therefore essential to model as two distinct stochastic processes.1Public Order Flow: The stream of transactions submitted by regular users to the public peer-to-peer network is characterized by its unpredictable and often bursty nature. This can be effectively modeled as a compound Poisson process. Let the number of public transactions arriving in the time interval [0,t], denoted by Np​(t), follow a Poisson distribution with a rate parameter λp​, representing the average number of transactions per unit of time.P(Np​(t)=k)=k!(λp​t)ke−λp​t​Each arriving transaction, j, carries an intrinsic value to the block builder, primarily its priority fee (or tip). This value, Vj​, is itself a random variable. To capture the observed distribution of fees, where many are small but a few can be very large, we model Vj​ as being drawn from a log-normal distribution, Vj​∼Log-Normal(ξ1​,ω12​). The total value from public transactions available to a builder at time t, known as the public signal P(t), is the cumulative sum of these individual transaction values.P(t)=j=1∑Np​(t)​Vj​Private Order Flow (Exclusive Order Flow - EOF): Sophisticated actors, known as searchers, often bypass the public mempool to submit their valuable transaction bundles (e.g., arbitrages, liquidations) directly to block builders. This private channel protects their strategies from being front-run by competitors. The arrival of this private order flow is also modeled as a compound Poisson process, but with a crucial modification to represent the competitive landscape among builders.For a market with n builders, the arrival of private bundles to a specific builder i is a Poisson process Ne,i​(t) with a builder-specific rate. This is modeled by introducing an access probability, πi​, which represents builder i's effectiveness at sourcing private deals. If the global arrival rate of private bundles is λe​, then the rate for builder i is λe​⋅πi​, where ∑i=1n​πi​ may be greater than 1, as searchers can send the same bundle to multiple builders. The value of each private bundle, Oj​, is also drawn from a log-normal distribution, Oj​∼Log-Normal(ξ2​,ω22​). The private signal for builder i at time t is thus :Ei​(t)=j=1∑Ne,i​(t)​Oj​The formal separation of order flow into a common public pool, P(t), and a builder-specific private pool, Ei​(t), is not merely a modeling convenience; it is the fundamental economic mechanism that drives the observed centralization in the block builder market. Empirical studies consistently show that the market share and profitability of top builders are strongly correlated with their access to this exclusive order flow, rather than simply their efficiency in processing public transactions.3 This creates a powerful positive feedback loop. A builder with superior EOF access (a higher πi​) can construct more valuable blocks. By consistently producing higher-value blocks, they win more MEV-Boost auctions, which enhances their reputation for reliable and profitable inclusion. This reputation, in turn, attracts more searchers and private order flow providers (OFAs), further increasing their πi​. This "rich-get-richer" dynamic, which originates from the initial assumption of heterogeneous access probabilities (πi​), provides a first-principles explanation for the emergent, macro-level phenomenon of market oligopoly and centralization that has been empirically observed.21.2 The EIP-1559 Fee Market: A Dual-Auction ModelEthereum's EIP-1559 transaction fee mechanism is often misunderstood. Rather than a single market, it is more accurately modeled as a dual system: a dynamic reserve price auction that governs transaction inclusion, layered on top of a first-price auction that governs priority and ordering. This distinction is paramount for correctly modeling MEV incentives.Base Fee as a Dynamic Reserve Price: For a transaction to be eligible for inclusion in block t, it must pay a minimum fee per unit of gas, known as the base_fee, denoted pt​. This fee functions as a protocol-enforced reserve price. The key innovation of EIP-1559 is that this reserve price is not static but adjusts algorithmically based on network demand, measured by the size of the preceding block, Qt−1​, relative to a target block size, B. Following the continuous formulation, the update rule is 6:pt​=pt−1​⋅eη(Qt−1​−B)/BHere, η is the adjustment parameter that controls the speed of price changes (set to 1/8 in Ethereum). The revenue generated from the base_fee is burned, meaning it is removed from the total supply of ETH. This ensures that builders have no incentive to manipulate block sizes to artificially inflate the base_fee, as they do not profit from it.7Priority Fee as a First-Price Auction: For the set of transactions willing to pay the reserve price pt​, their ultimate inclusion (if the block is full) and, critically, their ordering within the block are determined by an additional payment, the priority_fee or "tip." This tip is a direct payment to the block builder. This mechanism constitutes a classic first-price, pay-as-bid auction for preferential placement within the block.7 It is within this auction that MEV-seeking actors engage in intense bidding wars, often called Priority Gas Auctions (PGAs), to secure the transaction ordering necessary to execute their strategies.11The introduction of EIP-1559, while primarily aimed at improving user experience by making gas fees more predictable, had a profound second-order effect on the MEV landscape. It effectively clarified and isolated the market for transaction ordering. Before EIP-1559, the entire gas price was a single, undifferentiated bid in a chaotic first-price auction for both block inclusion and priority placement.8 This made it difficult for participants to disentangle the price of simply "getting into the block" from the premium required for "getting in first." EIP-1559 separated these costs.10 The base_fee now algorithmically prices network congestion (the cost of inclusion), while the priority_fee has become a pure, unadulterated market price for ordering preference. This separation makes the MEV game more legible and economically rational for sophisticated actors. A searcher can now precisely calculate the cost of inclusion (the known variable pt​) and focus their bidding strategy entirely on the PGA for the priority fee, bidding only what a specific block position is worth to them. Consequently, EIP-1559 did not eliminate MEV auctions; it institutionalized them, creating a more efficient—and more fiercely competitive—market for transaction ordering.1.3 Block Builder Incentives and the MEV-Boost AuctionIn the post-Merge, Proposer-Builder Separation (PBS) era of Ethereum, the role of constructing the block payload has been outsourced to a competitive market of specialized entities known as block builders. A builder's primary function is to solve a complex optimization problem: constructing the most profitable block possible from the available public and private transactions.The Builder's Knapsack Problem: Given a view of the mempool containing a set of available transactions Tavailable​, a builder's objective is to select a subset of transactions, Tselected​, that maximizes their total revenue. This revenue is the sum of all priority fees and any additional MEV payments (e.g., from private bundles). This selection is subject to the constraint that the total gas consumed by the selected transactions does not exceed the block gas limit, Lgas​. The builder's problem can be formulated as:maximizetx∈Tselected​∑​(priority_fee(tx)+MEV_payment(tx))subject totx∈Tselected​∑​gas_used(tx)≤Lgas​This is a variation of the 0-1 knapsack problem, which is known to be NP-hard.12 In practice, builders do not solve this problem to optimality due to time constraints. Instead, they employ sophisticated greedy heuristics, primarily sorting transactions and bundles by their effective gas price (i.e., total fee per unit of gas) and packing them into the block accordingly.The MEV-Boost Auction Model: Under PBS, the block constructed by a builder is not directly proposed to the network. Instead, it becomes a product to be sold in a higher-level auction to the validator who has been assigned the current slot, known as the proposer.2 This auction is facilitated by the MEV-Boost protocol. Let Vi​ be the total value (priority fees + MEV) of the block constructed by builder i. The builder submits this block to a trusted intermediary (a relay) along with a bid, bi​≤Vi​. The proposer only sees the bids from all builders and is cryptographically bound to select the block corresponding to the highest bid, max(bi​). The proposer receives the winning bid amount, bwinner​, and the winning builder's profit is their margin, Πi​=Vi​−bi​. This mechanism functions as a first-price, sealed-bid auction for the right to have one's block included on-chain.14The implementation of PBS, while designed to democratize MEV access for all validators and reduce their computational load 13, has inadvertently acted as a powerful force for re-centralization at the block production layer. By creating a specialized, high-stakes market for block building, PBS has raised the barriers to entry significantly.3 Success in this market requires sophisticated infrastructure, including low-latency global networking, private agreements with searchers for exclusive order flow, and advanced parallel transaction simulation capabilities. This environment strongly favors large, well-capitalized entities that can leverage economies of scale.5 As established previously, these dominant builders attract more exclusive order flow, which allows them to consistently produce higher-value blocks (Vi​). In the first-price MEV-Boost auction, these builders can afford to place higher bids than their smaller competitors while still retaining a profit margin, leading to inevitable market consolidation. Empirical data confirms this dynamic, with a very small number of builders being responsible for producing the vast majority of all Ethereum blocks.3 Therefore, a mechanism intended to promote decentralization at the validator level has, as a third-order effect, created a highly centralized and specialized oligopoly of block builders, effectively shifting the centralization pressure one layer up the stack rather than eliminating it.Section 2: The Calculus of Atomic MEV StrategiesThis section delves into the mathematical foundations of specific, atomic MEV strategies. By deriving the precise profitability conditions, we can model the decision-making calculus of an adversarial agent determining whether to execute an attack.2.1 Sandwich Attacks on Constant Function Market Makers (CFMMs)A sandwich attack is one of the most common forms of MEV, where an attacker exploits a victim's trade on a decentralized exchange by "sandwiching" it between their own front-run and back-run trades to profit from the induced price slippage.15Uniswap V2 Model: The canonical example is a constant product market maker (CPMM), such as Uniswap V2, governed by the invariant x⋅y=k, where x and y are the reserves of two tokens in a liquidity pool. When a victim submits a trade of Δxv​ of token X for token Y, an attacker observes this in the mempool. They execute a front-run trade, buying token Y with Δxf​ of token X, which pushes the price of Y up. The victim's trade then executes at this worse price. Finally, the attacker back-runs the victim, selling the token Y they acquired back for token X at the now even higher price, realizing a profit in token X. The profitability of this attack is constrained by the victim's specified slippage tolerance, which sets an upper limit on the price impact the attacker can profitably induce.15 The optimal front-run amount, Δxf∗​, that maximizes profit up to this slippage limit can be approximated analytically or found numerically through binary search.16General CFMM Profitability Bounds: To generalize beyond CPMMs, we adopt a more rigorous framework applicable to any CFMM.18 Let the CFMM's trading function be described by a forward exchange function G(⋅), which gives the amount of output token for a given input amount. The net profit and loss (PNL) for a sandwich attacker is given by:PNL(Δ,η)=Δsand′​−Δsand​where Δ is the victim's trade size, η is the victim's slippage tolerance (a percentage), Δsand​ is the size of the attacker's front-run trade, and Δsand′​ is the amount of the input asset the attacker receives back from their back-run trade.Derivation of Bounds: The profitability of a sandwich attack is fundamentally determined by the "curvature" of the CFMM's trading function, which dictates its price impact. We can bound the price impact of the CFMM with linear functions, where the price is at most μ and at least κ times the input amount. Under these assumptions, the optimal front-run trade size required to push the price to the victim's slippage limit is bounded. A key result is the upper bound on the attacker's required capital 18:Δsand​≤(μ−κημ​−1)ΔThis crucial inequality demonstrates that the size of the front-run trade (the attacker's capital requirement) is linear in the victim's slippage tolerance η and is highly dependent on the pool's liquidity characteristics, as captured by the curvature parameters μ and κ. A pool with high liquidity will have a "flatter" curve, meaning μ and κ are close, which makes the term (μ−κ) small and thus requires a very large Δsand​ to induce the same slippage, making attacks more capital-intensive and less profitable. The final PNL can also be bounded, providing a clear mathematical condition for when an attack is profitable net of costs, which can be used to inform both attack execution and defense design.The formal derivation of sandwich profitability reveals a critical principle: a primary determinant of a protocol's vulnerability to this form of MEV is the mathematical structure of the AMM itself. The choice of AMM curve is therefore not merely a decision about capital efficiency for liquidity providers; it is a fundamental security parameter. The profitability bounds are explicit functions of the curvature parameters μ and κ.18 An AMM with a "flatter" trading curve exhibits lower price impact for a given trade size. This directly reduces the potential profit an attacker can extract, as their entire strategy is predicated on manufacturing and exploiting this price impact. Protocols that are designed to reduce price impact, such as those that aggregate liquidity across multiple venues or use more capital-efficient curves for specific asset pairs (e.g., Curve's stableswap invariant for stablecoins, or Uniswap v3's concentrated liquidity), effectively flatten the curve for many trades.19 This elevates mechanism design from a feature optimization to a core security consideration, demonstrating that protocol architecture can serve as an intrinsic defense against certain types of MEV.2.2 Back-running and LiquidationsIn decentralized lending protocols, liquidations are a critical mechanism for maintaining solvency. They occur when the value of a borrower's collateral falls below a required threshold, making the loan under-collateralized. This event creates a profitable opportunity for an agent, a liquidator, to repay the debt and claim the collateral at a discount. This is a form of back-running MEV, as the liquidator must execute their transaction immediately after the price oracle update that renders the position liquidatable.20Liquidation Condition: A lending position becomes eligible for liquidation when its Health Factor (HF) drops below a protocol-defined threshold, which is typically 1. The Health Factor is a ratio that represents the safety of the loan, formally defined as 21:$$ \text{HF} = \frac{\sum_{i}(\text{Collateral}_i \times \text{Price}_i \times \text{Liquidation_Threshold}i)}{\sum{j}(\text{Debt}_j \times \text{Price}_j)} $$A liquidation is triggered when a new price feed from an oracle updates either a collateral or debt price, causing the calculated HF to fall below 1.Profitability Model: A liquidator is an agent who monitors for liquidatable positions. Upon finding one, they can repay a portion of the borrower's debt and, in return, seize a corresponding amount of the borrower's collateral. To incentivize this action, the protocol allows the liquidator to claim the collateral at a discount, known as the liquidation bonus. The net profit, Πliq​, for a liquidator is the value of the discounted collateral received, minus the value of the debt they repaid and any transaction costs:$$ \Pi_{liq} = (\text{Value of Collateral Seized}) - (\text{Value of Debt Repaid}) - C_{gas} - C_{slippage} $$where the value of collateral seized includes the liquidation bonus (e.g., a 5% bonus means they receive 105% of the collateral value corresponding to the repaid debt). The liquidator's action is a quintessential back-run: they must race to get their liquidation transaction included in the block immediately following the oracle price update that created the opportunity. This creates a highly competitive PGA among liquidator bots for that specific, time-sensitive opportunity.24MEV-Builder Extract: In a competitive liquidation environment with multiple bots vying for the same loan, they will bid up their priority fees to win the PGA and secure the profitable back-run. The maximum amount a rational liquidator is willing to bid as a priority fee is their expected net profit, Πliq​. In an efficient, highly competitive auction, the winning bid will approach this value. Therefore, the value extracted by the MEV-aware block builder is the priority fee paid by the winning liquidator, which can be nearly the entire profit from the liquidation itself, leaving the liquidator with a minimal margin.The design of the liquidation mechanism itself has profound second-order effects on the systemic stability of the entire DeFi ecosystem, particularly during periods of high market volatility. A simple, fixed-spread mechanism, such as Aave's typical 5-10% liquidation bonus, offers a predictable and attractive profit for liquidators.20 However, this design can introduce dangerous pro-cyclicality during a market crash. When prices fall rapidly, many positions become liquidatable simultaneously. The fixed bonus incentivizes a "race to the bottom," where numerous liquidators compete to dump large quantities of the same collateral asset onto the market to claim their reward. This mass-selling pressure can further suppress the collateral's price, which in turn triggers even more liquidations, potentially creating a cascading "death spiral" that threatens protocol solvency.20 In contrast, an auction-based liquidation mechanism, as used by MakerDAO, forces liquidators to compete on the discount they are willing to accept.24 This competition internalizes the price impact of the liquidation, often resulting in smaller liquidation sizes and less severe shocks to the market. This reveals a critical trade-off in mechanism design: the choice lies between the micro-level efficiency of ensuring individual loans are promptly repaid and the macro-level systemic stability required to prevent cascading failures that could endanger the entire protocol.Section 3: Game-Theoretic Models of MEV CompetitionThis section analyzes the strategic interactions that arise when multiple adversarial agents compete for the same MEV opportunities. By modeling these scenarios using game theory, we can derive equilibrium behaviors and understand how value is distributed among participants.3.1 The Priority Gas Auction (PGA)The competition to capture a publicly visible and profitable MEV opportunity, such as an arbitrage or a liquidation, can be modeled as a game among N competing searcher bots. This game takes the form of a Priority Gas Auction (PGA).11Game Formulation: Drawing on foundational work in the field, we can model the PGA as a first-price, all-pay auction with imperfect information.7Players: A set of N risk-neutral searcher bots.Prize: A single, indivisible MEV opportunity with a commonly known value, V.Bids: Each player i submits a transaction with a priority fee (tip) of bi​. The transaction is designed to capture the prize V.Winner Determination: The block builder includes the transaction with the highest valid bid, bmax​. The winner's transaction is executed first, allowing them to capture the prize. Their net payoff is Uw​=V−bmax​−Cgas_win​.All-Pay Condition: A crucial feature of on-chain auctions is that transactions from losing bidders are also often included in the block (or at least attempted), where they fail but still consume gas. This means losers pay a penalty. Their payoff is Ul​=−Cgas_fail​. This "all-pay" nature significantly raises the stakes of the auction.12Imperfect Information: In a real-world setting, players do not observe competing bids instantaneously due to network latency and mempool propagation delays. A player with lower latency has an informational advantage, as they can see and react to competitors' bids more quickly.113.2 Equilibrium Bidding StrategiesTo understand the outcomes of these auctions, we can analyze the equilibrium bidding strategies of the players. For tractability, we can analyze a simplified version of the PGA and then extrapolate the results.Simplified Setting: Consider a PGA with N players competing for a prize of value V. To simplify, we assume the cost for losers is zero (relaxing the all-pay condition to a standard first-price auction) and that information is perfect (all bids are known instantly). Each player's valuation for the prize is V.Equilibrium Strategy: In a symmetric Nash Equilibrium of a standard first-price auction with N bidders whose valuations are drawn from a known distribution, players will "shade" their bids below their true valuation. However, in the specific case of a public MEV opportunity, the value V is common knowledge. This transforms the game into a Bertrand-style competition. Rational players will incrementally outbid each other until the winning bid is just below V. The player who is willing to accept the smallest profit margin (or who acts last) will win. As the number of competitors (N) increases, the intensity of this competition drives the winning bid, bmax​, arbitrarily close to V.Application to MEV: This model predicts that for any public MEV opportunity, the competition among searchers will be so fierce that nearly the entire value of the opportunity will be bid away in the form of priority fees. The expected profit for any individual searcher, V−bmax​, approaches zero as N increases. The true economic beneficiary of the MEV opportunity is not the searcher who discovers it, but the auctioneer—the block builder—who collects the winning bid bmax​ as pure profit.12This game-theoretic analysis leads to a significant conclusion about the structure of the MEV supply chain: the business of searching for public MEV opportunities is destined to become a commoditized, zero-sum game. The barrier to entry for identifying a simple public arbitrage on a major DEX is relatively low, ensuring that the number of competitors, N, for any such opportunity will be large. The equilibrium outcome of the resulting PGA is that searcher profit margins are competed down to near zero, with the vast majority of the value flowing "upstream" to the block builders who conduct the auction. This creates a powerful and unavoidable economic pressure for serious searchers to evolve. The only sustainable long-term strategy is to exit the hyper-competitive public MEV game and focus on developing private MEV opportunities. This can be achieved through sourcing exclusive order flow, discovering complex multi-leg arbitrage routes that are not easily detectable, or establishing private arrangements for liquidations. This drive to re-introduce information asymmetry and escape the brutal efficiency of the public PGA is the core economic rationale for the existence and growth of the private order flow ecosystem modeled in Section 1.1.$$\rule{\textwidth}{0.4pt}$$Code snippet\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[a4paper, margin=1in]{geometry}

\title{\textbf{A Framework for Simulating Adversarial Economics in Blockchain Mempools: Formal Models}}
\author{Quantitative Research Division}
\date{\today}

\begin{document}
\maketitle

\abstract{This document provides the formal mathematical models underpinning a simulation environment for Maximal Extractable Value (MEV) and mempool dynamics. We formalize transaction arrival processes, the EIP-1559 fee market, block builder incentives, the profitability calculus for sandwich and liquidation attacks, and the game-theoretic interactions between competing adversarial agents.}

\section{The Mempool as a Dynamic Economic System}
The mempool is the dynamic pre-consensus layer where pending transactions compete for block inclusion. Its economic properties are defined by the arrival of value (transactions) and the mechanisms for pricing block space (auctions).

\subsection{Formalizing Transaction and Bundle Arrival}
We model two primary sources of order flow: public user transactions and private searcher bundles.

\subsubsection{Public Order Flow}
The arrival of public transactions is modeled as a compound Poisson process. The number of transactions arriving in an interval $[0, t]$, denoted $N_p(t)$, follows a Poisson distribution with rate $\lambda_p$:
$$P(N_p(t) = k) = \frac{(\lambda_p t)^k e^{-\lambda_p t}}{k!}$$
The value of each transaction $j$, primarily its priority fee, $V_j$, is drawn from a log-normal distribution, $V_j \sim \text{Log-Normal}(\xi_1, \omega_1^2)$. The total public value signal at time $t$ is the sum of these values:
$$P(t) = \sum_{j=1}^{N_p(t)} V_j$$

\subsubsection{Private Order Flow (EOF)}
Private bundles from searchers to builders are also modeled as a compound Poisson process, but with builder-specific access probabilities. For a builder $i$ among $n$ builders, the number of private bundles received, $N_{e,i}(t)$, follows a Poisson process with rate $\lambda_e \cdot \pi_i$, where $\lambda_e$ is the global bundle arrival rate and $\pi_i$ is builder $i$'s probability of receiving a given bundle. The value of each bundle $j$, $O_j$, is drawn from a log-normal distribution, $O_j \sim \text{Log-Normal}(\xi_2, \omega_2^2)$. The private signal for builder $i$ is:
$$E_i(t) = \sum_{j=1}^{N_{e,i}(t)} O_j$$

\subsection{The EIP-1559 Fee Market: A Dual-Auction Model}
EIP-1559 separates the cost of inclusion (base fee) from the cost of priority (priority fee).

\subsubsection{Base Fee as a Dynamic Reserve Price}
The base fee for block $t$, $p_t$, is a reserve price per gas unit. It updates based on the size of the previous block, $Q_{t-1}$, relative to a target size, $B$, using an adjustment parameter $\eta$:
$$p_{t} = p_{t-1} \cdot e^{\eta(Q_{t-1} - B)/B}$$
The base fee revenue is burned.

\subsubsection{Priority Fee as a First-Price Auction}
Transactions pay an additional priority fee (tip) directly to the builder for preferential ordering. This constitutes a first-price, pay-as-bid auction for block space priority, known as a Priority Gas Auction (PGA).

\subsection{Block Builder Incentives and the MEV-Boost Auction}
Builders construct blocks to maximize profit, which are then sold in the MEV-Boost auction.

\subsubsection{The Builder's Knapsack Problem}
A builder selects a subset of transactions $T_{\text{selected}}$ from the available set $T_{\text{available}}$ to maximize revenue, subject to the block gas limit $L_{\text{gas}}$:
$$ \text{maximize} \sum_{tx \in T_{\text{selected}}} (\text{priority\_fee}(tx) + \text{MEV\_payment}(tx)) \quad \text{s.t.} \quad \sum_{tx \in T_{\text{selected}}} \text{gas\_used}(tx) \le L_{\text{gas}} $$

\subsubsection{The MEV-Boost Auction Model}
This is a first-price, sealed-bid auction. Builder $i$ constructs a block of total value $V_i$ and submits a bid $b_i \le V_i$. The proposer selects the highest bid, $b_{\text{winner}}$. The winning builder's profit is $\Pi_i = V_i - b_i$.

\section{The Calculus of Atomic MEV Strategies}

\subsection{Sandwich Attacks on Constant Function Market Makers (CFMMs)}
We derive the profitability bounds for a sandwich attack on a general CFMM. Let $\Delta$ be the victim trade size and $\eta$ be the slippage tolerance. The attacker's profit is $\text{PNL}(\Delta, \eta) = \Delta'_{\text{sand}} - \Delta_{\text{sand}}$.

\subsubsection{Profitability Bounds}
The profitability is determined by the CFMM's price impact, which can be bounded by linear functions with slopes $\mu$ (upper) and $\kappa$ (lower). The required front-run trade size, $\Delta_{\text{sand}}$, is bounded above by:
$$\Delta_{\text{sand}} \le \left(\frac{\eta\mu}{\mu - \kappa} - 1\right)\Delta$$
This shows that the attacker's capital cost is linear in the victim's slippage tolerance and inversely related to the pool's curvature $(\mu - \kappa)$. The PNL is profitable if it exceeds the total gas costs of the front-run and back-run transactions. The minimum victim trade size for profitability is derived by setting the expected PNL equal to the transaction costs and solving for $\Delta$.

\subsection{Back-running and Liquidations}
A liquidation opportunity arises when a loan's Health Factor (HF) falls below 1.
$$ \text{HF} = \frac{\sum_{i}(\text{Collateral}_i \times \text{Price}_i \times \text{Liquidation\_Threshold}_i)}{\sum_{j}(\text{Debt}_j \times \text{Price}_j)} < 1 $$

\subsubsection{Profitability Model}
A liquidator repays debt to seize collateral at a discount (liquidation bonus, $\lambda$). The net profit, $\Pi_{\text{liq}}$, is:
$$ \Pi_{\text{liq}} = (\text{Value of Collateral Seized}) - (\text{Value of Debt Repaid}) - C_{\text{gas}} $$
where Value of Collateral Seized includes the bonus. The opportunity is a back-run on the oracle price update that triggers the liquidatable state.

\subsubsection{MEV-Builder Extract}
In a competitive PGA for the liquidation, multiple liquidators will bid up their priority fee. The maximum rational bid is $\Pi_{\text{liq}}$. The MEV extracted by the builder is the winning priority fee, which will approach $\Pi_{\text{liq}}$ as competition increases. A liquidation is profitable for a liquidator only if $\Pi_{\text{liq}} > 0$ after accounting for the priority fee they expect to pay.

\section{Game-Theoretic Models of MEV Competition}

\subsection{The Priority Gas Auction (PGA)}
We model the competition for an MEV opportunity of value $V$ as a first-price, all-pay auction among $N$ searchers.
\begin{itemize}
    \item \textbf{Players:} $N$ risk-neutral searcher bots.
    \item \textbf{Prize:} An MEV opportunity of value $V$.
    \item \textbf{Bids:} Each player $i$ submits a transaction with priority fee $b_i$.
    \item \textbf{Payoffs:}
        \begin{itemize}
            \item Winner (highest bid $b_{\text{max}}$): $U_w = V - b_{\text{max}} - C_{\text{gas\_win}}$
            \item Losers: $U_l = -C_{\text{gas\_fail}}$
        \end{itemize}
\end{itemize}

\subsection{Equilibrium Bidding Strategies}
In a simplified first-price auction setting (non-all-pay) where the value $V$ is common knowledge, the game resembles a Bertrand competition.
\begin{itemize}
    \item \textbf{Strategy:} Players will incrementally outbid each other.
    \item \textbf{Equilibrium:} The winning bid $b_{\text{max}}$ will be driven up to $V - \epsilon$, where $\epsilon$ is the smallest possible profit margin a player is willing to accept. As the number of players $N \to \infty$, $b_{\text{max}} \to V$.
    \item \textbf{Implication:} The searcher's profit margin approaches zero. The vast majority of the MEV opportunity's value ($V$) is captured by the block builder in the form of the winning priority fee.
\end{itemize}

\end{document}
Part II: A Python-Based Adversarial Economics LaboratoryThis section translates the formal models from Part I into a functional, extensible, and reproducible Python simulation environment. The code is presented in a single, Colab-ready block, designed to serve as a foundational toolkit for an MEV research lab.Table 1: Simulation Configuration ParametersA core requirement for a rigorous laboratory is reproducibility. The following table centralizes all tunable parameters of the simulation, acting as a manifest for any given experimental run. This design allows for systematic sensitivity analysis and ensures that results can be independently verified and built upon. It separates the model's logic from its parameterization, making the framework more flexible and professional.Parameter CategoryParameter NameDescriptionData TypeDefault ValueMempool DynamicsTX_ARRIVAL_RATE_LAMBDAMean arrival rate (λp​) for public transactions (tx/sec).float5.0BUNDLE_ARRIVAL_RATE_LAMBDAMean arrival rate (λe​) for private bundles (bundles/sec).float0.5SIMULATION_DURATIONTotal duration of the simulation in seconds.int120Blockchain StateBLOCK_INTERVALTime between blocks in seconds.int12INITIAL_BASE_FEEStarting base_fee in Gwei.int20BLOCK_GAS_LIMITMaximum gas per block.int30,000,000CFMM ConfigurationINITIAL_RESERVE_XInitial liquidity of Token X (e.g., WETH) in the simulated pool.float1000.0INITIAL_RESERVE_YInitial liquidity of Token Y (e.g., USDC) in the simulated pool.float2,000,000.0Gas Cost ModelGAS_PER_SWAPGas cost for a standard token swap.int150,000GAS_PER_BUNDLEBase gas cost for executing a 2-tx sandwich bundle.int50,000Adversarial AgentsNUM_SANDWICH_BOTSNumber of competing sandwich bots in the simulation.int1BOT_LATENCY_MSSimulated network/processing latency for bots in milliseconds.int50Experiment ControlDETERMINISTIC_SEEDSeed for all random number generators to ensure reproducibility.int42Section 4-6: Simulator Implementation and ExperimentsThe following Python code block contains the complete implementation of the mempool simulator, adversarial agents, and experimental setups. The architecture is object-oriented and event-driven, designed for modularity and extension. It includes:Core Components: Mempool, BlockBuilder, VirtualMachine, and an event Clock.Order Flow Simulation: A TransactionGenerator that creates synthetic user trades based on the Poisson process model.Adversarial Agents: A SandwichBot class that implements the detection and execution logic based on the profitability calculus derived in Part I.Modular Interfaces: Abstract Base Classes for CFMM and CostModel to facilitate plugging in different implementations.Experiments: Code to run the analyses described in the outline, demonstrating the erosion of sandwich profits under competition and congestion.Unit Tests: A set of unittest cases to verify the core logic of the sandwich bot's profitability calculations.Reproducibility: The use of a deterministic seed and extensive comments to guide future extensions, such as replaying real mempool data, for which resources like 26 may serve as useful references.Python# MEV/Mempool Simulation and Adversarial Economics Laboratory
#
# This Colab-ready Python script implements a discrete-time event simulation
# of a blockchain mempool, block construction, and adversarial MEV extraction.
# It is designed as a foundational toolkit for prototyping and analyzing
# MEV strategies like sandwich attacks.

# --- Core Dependencies ---
import heapq
import time
import random
import numpy as np
import unittest
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Tuple, Any, Dict, Optional

# --- Configuration Parameters (from Table 1) ---
# This dictionary centralizes all simulation parameters for reproducibility.
CONFIG = {
    # Mempool Dynamics
    "TX_ARRIVAL_RATE_LAMBDA": 5.0,  # tx/sec
    "BUNDLE_ARRIVAL_RATE_LAMBDA": 0.5, # bundles/sec (not used in this simplified model)
    "SIMULATION_DURATION": 120, # seconds

    # Blockchain State
    "BLOCK_INTERVAL": 12, # seconds
    "INITIAL_BASE_FEE": 20, # Gwei
    "BLOCK_GAS_LIMIT": 30_000_000,

    # CFMM Configuration
    "INITIAL_RESERVE_X": 1000.0, # e.g., WETH
    "INITIAL_RESERVE_Y": 2_000_000.0, # e.g., USDC

    # Gas Cost Model
    "GAS_PER_SWAP": 150_000,
    "GAS_PER_BUNDLE": 50_000, # Overhead for bundle execution

    # Adversarial Agents
    "NUM_SANDWICH_BOTS": 1,
    "BOT_LATENCY_MS": 50, # milliseconds

    # Experiment Control
    "DETERMINISTIC_SEED": 42,
}

# --- Setup for Reproducibility ---
def set_seed(seed: int):
    """Sets the seed for all random number generators."""
    random.seed(seed)
    np.random.seed(seed)

set_seed(CONFIG)

# --- Section 4: Architecture of the Mempool Simulator ---

# 4.1. Core Components & Event-Driven Loop

@dataclass(order=True)
class Event:
    """Represents an event in the simulation queue."""
    timestamp: float
    action: str
    data: Any = field(compare=False)

@dataclass
class Transaction:
    """Represents a single blockchain transaction."""
    tx_id: int
    sender: str
    arrival_time: float
    gas_limit: int
    priority_fee_gwei: float # Per gas unit
    # EIP-1559 fields
    max_fee_per_gas: float # Includes base_fee + priority_fee
    # For swaps
    is_swap: bool = False
    swap_details: Dict = field(default_factory=dict)

    @property
    def effective_gas_price(self) -> float:
        """Priority fee per gas, used for sorting."""
        return self.priority_fee_gwei

@dataclass
class Bundle:
    """Represents an atomic bundle of transactions from a searcher."""
    bundle_id: str
    transactions: List
    submit_time: float
    
    @property
    def total_gas_limit(self) -> int:
        return sum(tx.gas_limit for tx in self.transactions)

    @property
    def effective_gas_price(self) -> float:
        """Calculates the effective gas price for the entire bundle."""
        total_priority_fee = sum(tx.priority_fee_gwei * tx.gas_limit for tx in self.transactions)
        return total_priority_fee / self.total_gas_limit if self.total_gas_limit > 0 else 0


class Clock:
    """Manages simulation time and the event queue."""
    def __init__(self):
        self.current_time = 0.0
        self.event_queue =

    def schedule_event(self, delay: float, action: str, data: Any = None):
        """Schedules a future event."""
        heapq.heappush(self.event_queue, Event(self.current_time + delay, action, data))

    def next_event(self) -> Optional[Event]:
        """Pops the next event from the queue and advances time."""
        if not self.event_queue:
            return None
        event = heapq.heappop(self.event_queue)
        self.current_time = event.timestamp
        return event

class Mempool:
    """Simulates the transaction mempool."""
    def __init__(self):
        self.pending_txs: Dict = {}
        self.pending_bundles: Dict = {}

    def add_transaction(self, tx: Transaction):
        print(f" Mempool: Received TX {tx.tx_id} with priority {tx.priority_fee_gwei:.2f} Gwei")
        self.pending_txs[tx.tx_id] = tx

    def add_bundle(self, bundle: Bundle):
        print(f" Mempool: Received Bundle {bundle.bundle_id} from bot.")
        self.pending_bundles[bundle.bundle_id] = bundle

    def get_pending_items(self) -> List]:
        """Returns all pending items sorted by effective gas price."""
        items =
        for tx in self.pending_txs.values():
            items.append((-tx.effective_gas_price, tx)) # Use negative for max-heap behavior
        for bundle in self.pending_bundles.values():
            items.append((-bundle.effective_gas_price, bundle))
        
        items.sort(key=lambda x: x)
        return items

    def clear(self):
        """Clears the mempool after a block is built."""
        self.pending_txs.clear()
        self.pending_bundles.clear()
        
# 5.3. External Module Interfaces (and Concrete Implementations)

class CostModel(ABC):
    """Abstract Base Class for gas cost modeling."""
    @abstractmethod
    def get_tx_cost(self, tx: Transaction, base_fee: float) -> float:
        pass
    
    @abstractmethod
    def get_bundle_cost(self, bundle: Bundle, base_fee: float) -> float:
        pass

class SimpleCostModel(CostModel):
    """A simple, fixed-cost implementation of the CostModel."""
    def get_tx_cost(self, tx: Transaction, base_fee: float) -> float:
        """Calculates total cost in ETH (not Gwei)."""
        fee = min(tx.max_fee_per_gas, base_fee + tx.priority_fee_gwei)
        return (fee * tx.gas_limit) / 1e9 # Convert Gwei to ETH
    
    def get_bundle_cost(self, bundle: Bundle, base_fee: float) -> float:
        return sum(self.get_tx_cost(tx, base_fee) for tx in bundle.transactions)

class CFMM(ABC):
    """Abstract Base Class for a Constant Function Market Maker."""
    @abstractmethod
    def get_reserves(self) -> Tuple[float, float]:
        pass

    @abstractmethod
    def calculate_amount_out(self, amount_in: float, reserve_in: float, reserve_out: float) -> float:
        pass
    
    @abstractmethod
    def execute_swap(self, amount_in: float, token_in: str) -> float:
        pass

class UniswapV2CFMM(CFMM):
    """Implements a simple Uniswap V2 style constant product AMM."""
    def __init__(self, reserve_x: float, reserve_y: float):
        self.reserve_x = reserve_x # Token X (e.g., WETH)
        self.reserve_y = reserve_y # Token Y (e.g., USDC)
        self.k = self.reserve_x * self.reserve_y
        self.fee = 0.003 # 0.3% fee

    def get_reserves(self) -> Tuple[float, float]:
        return self.reserve_x, self.reserve_y

    def calculate_amount_out(self, amount_in: float, reserve_in: float, reserve_out: float) -> float:
        amount_in_with_fee = amount_in * (1 - self.fee)
        numerator = amount_in_with_fee * reserve_out
        denominator = reserve_in + amount_in_with_fee
        return numerator / denominator

    def execute_swap(self, amount_in: float, token_in: str) -> float:
        if token_in == 'X':
            reserve_in, reserve_out = self.reserve_x, self.reserve_y
            amount_out = self.calculate_amount_out(amount_in, reserve_in, reserve_out)
            self.reserve_x += amount_in
            self.reserve_y -= amount_out
        elif token_in == 'Y':
            reserve_in, reserve_out = self.reserve_y, self.reserve_x
            amount_out = self.calculate_amount_out(amount_in, reserve_in, reserve_out)
            self.reserve_y += amount_in
            self.reserve_x -= amount_out
        else:
            raise ValueError("Invalid token_in specified")
        
        # In a real scenario, k would slightly increase due to fees.
        # For simplicity, we can re-calculate it, but it's not strictly necessary for this model.
        # self.k = self.reserve_x * self.reserve_y
        return amount_out
        
# 4.3. Block Construction and Fee Auction Simulation

class BlockBuilder:
    """Simulates a block builder creating a block."""
    def __init__(self, mempool: Mempool, gas_limit: int):
        self.mempool = mempool
        self.gas_limit = gas_limit

    def build_block(self, base_fee: float) -> Tuple[List[Any], int]:
        """Builds a block using a greedy strategy."""
        print(f" Builder: Starting block construction (Base Fee: {base_fee:.2f} Gwei).")
        
        block_content =
        gas_used = 0
        
        pending_items = self.mempool.get_pending_items()
        
        for _, item in pending_items:
            if isinstance(item, Transaction):
                if item.max_fee_per_gas < base_fee:
                    continue # Skip tx that can't pay base fee
                if gas_used + item.gas_limit <= self.gas_limit:
                    block_content.append(item)
                    gas_used += item.gas_limit
            elif isinstance(item, Bundle):
                if gas_used + item.total_gas_limit <= self.gas_limit:
                    # For simplicity, assume all txs in bundle meet base_fee
                    block_content.append(item)
                    gas_used += item.total_gas_limit

        print(f" Builder: Block built with {len(block_content)} items, {gas_used} gas.")
        return block_content, gas_used

class VirtualMachine:
    """Simulates the execution of transactions in a block."""
    def __init__(self, cfmm: CFMM):
        self.cfmm = cfmm
        self.sandwich_profits =

    def execute_block(self, block_content: List[Any]):
        print(f" VM: Executing block...")
        for item in block_content:
            if isinstance(item, Transaction) and item.is_swap:
                self.execute_swap(item)
            elif isinstance(item, Bundle):
                self.execute_sandwich(item)
        print(f" VM: Block execution finished.")

    def execute_swap(self, tx: Transaction):
        details = tx.swap_details
        amount_out = self.cfmm.execute_swap(details['amount_in'], details['token_in'])
        print(f"  - Executed victim swap: {details['amount_in']:.2f} {details['token_in']} for {amount_out:.2f} {details['token_out']}")

    def execute_sandwich(self, bundle: Bundle):
        frontrun_tx = bundle.transactions
        backrun_tx = bundle.transactions
        
        # Execute frontrun
        amount_y_received = self.cfmm.execute_swap(frontrun_tx.swap_details['amount_in'], frontrun_tx.swap_details['token_in'])
        print(f"  - Executed SANDWICH FRONT-RUN: {frontrun_tx.swap_details['amount_in']:.2f} X for {amount_y_received:.2f} Y")
        
        # The victim tx would be executed here by the VM loop, but for a bundle, we know its content.
        # We find the victim tx in the block and execute it.
        # In a more robust sim, the VM would have the full block and execute txs in order.
        # Here we assume the bundle was built around a known victim tx that is also in the block.
        # For this simulation, the victim is executed *after* the frontrun.
        
        # Execute backrun
        backrun_tx.swap_details['amount_in'] = amount_y_received # The backrun sells all Y received
        amount_x_final = self.cfmm.execute_swap(backrun_tx.swap_details['amount_in'], backrun_tx.swap_details['token_in'])
        print(f"  - Executed SANDWICH BACK-RUN: {backrun_tx.swap_details['amount_in']:.2f} Y for {amount_x_final:.2f} X")
        
        profit = amount_x_final - frontrun_tx.swap_details['amount_in']
        self.sandwich_profits.append(profit)
        print(f"  - GROSS Sandwich Profit: {profit:.4f} X")

# 4.2. Simulating the Order Flow

class TransactionGenerator:
    """Generates synthetic user transactions."""
    def __init__(self, clock: Clock, mempool: Mempool, arrival_rate: float):
        self.clock = clock
        self.mempool = mempool
        self.arrival_rate = arrival_rate
        self.tx_counter = 0

    def start(self):
        self.schedule_next_tx()

    def schedule_next_tx(self):
        delay = np.random.exponential(1.0 / self.arrival_rate)
        self.clock.schedule_event(delay, "TX_ARRIVAL", self)

    def generate_transaction(self, current_time: float):
        self.tx_counter += 1
        
        # Make one of the transactions a large, juicy target for sandwiching
        is_victim = (self.tx_counter % 20 == 0)
        
        # Trade WETH (X) for USDC (Y)
        amount_in = np.random.lognormal(mean=1.0, sigma=1.5)
        if is_victim:
            amount_in *= 10 # Make victim trade larger
            print(f"--- VICTIM TX {self.tx_counter} GENERATED ---")
        
        tx = Transaction(
            tx_id=self.tx_counter,
            sender=f"user_{self.tx_counter}",
            arrival_time=current_time,
            gas_limit=CONFIG,
            priority_fee_gwei=np.random.uniform(1, 10),
            max_fee_per_gas=CONFIG + 20,
            is_swap=True,
            swap_details={
                "amount_in": amount_in,
                "token_in": "X",
                "token_out": "Y",
                "slippage_tolerance": 0.01 # 1% slippage
            }
        )
        self.mempool.add_transaction(tx)
        self.schedule_next_tx()

    # TODO: Implement real mempool trace replay here.
    # def load_mempool_trace(file_path):
    #     """
    #     This function would parse a file containing historical mempool data
    #     (e.g., from Flashbots data archive) and schedule TX_ARRIVAL events
    #     based on the timestamps in the data, instead of using synthetic generation.
    #     """
    #     pass

# --- Section 5: Implementing Adversarial MEV Agents ---

# 5.1. The Sandwich Bot Agent

class SandwichBot:
    """An agent that detects and executes sandwich attacks."""
    def __init__(self, bot_id: int, clock: Clock, mempool: Mempool, cfmm: CFMM, cost_model: CostModel):
        self.bot_id = bot_id
        self.clock = clock
        self.mempool = mempool
        self.cfmm = cfmm
        self.cost_model = cost_model
        self.latency = CONFIG / 1000.0 # convert to seconds

    def detect_and_execute(self, victim_tx: Transaction, base_fee: float):
        """Main logic loop for the bot, triggered by a new transaction."""
        # Simulate bot's reaction time
        self.clock.schedule_event(self.latency, "BOT_ACTION", data={"bot": self, "victim_tx": victim_tx, "base_fee": base_fee})

    def perform_action(self, victim_tx: Transaction, base_fee: float):
        """The bot's action after its latency delay."""
        print(f" Bot {self.bot_id}: Analyzing TX {victim_tx.tx_id} for sandwich opportunity.")
        
        profitability = self.calculate_sandwich_profitability(victim_tx, base_fee)
        
        if profitability and profitability["net_profit_eth"] > 0:
            print(f" Bot {self.bot_id}: Profitable sandwich found! Net profit: {profitability['net_profit_eth']:.6f} ETH. Submitting bundle.")
            self.execute_attack(victim_tx, profitability, base_fee)
        else:
            print(f" Bot {self.bot_id}: No profitable sandwich for TX {victim_tx.tx_id}.")

    def calculate_sandwich_profitability(self, victim_tx: Transaction, base_fee: float) -> Optional:
        """Implements the profitability calculus from Section 2.1."""
        if not victim_tx.is_swap or victim_tx.swap_details['token_in']!= 'X':
            return None

        # Get initial state of the pool
        reserve_x, reserve_y = self.cfmm.get_reserves()
        
        # Calculate victim's expected output without interference
        amount_out_victim_no_frontrun = self.cfmm.calculate_amount_out(
            victim_tx.swap_details['amount_in'], reserve_x, reserve_y
        )
        min_amount_out_victim = amount_out_victim_no_frontrun * (1 - victim_tx.swap_details['slippage_tolerance'])

        # --- Find optimal frontrun amount ---
        # We can use a numerical optimization (e.g., binary search) or an analytical formula.
        # For simplicity, we'll test a range of frontrun amounts.
        # A more advanced bot would use a solver.
        
        best_profit = -1e18
        optimal_frontrun = 0
        
        # Search for optimal frontrun_x from 0.1% to 100% of victim's trade size
        for ratio in np.linspace(0.001, 1.0, 100):
            frontrun_x = victim_tx.swap_details['amount_in'] * ratio
            
            # 1. Simulate frontrun
            amount_out_y_bot = self.cfmm.calculate_amount_out(frontrun_x, reserve_x, reserve_y)
            reserve_x_after_frontrun = reserve_x + frontrun_x
            reserve_y_after_frontrun = reserve_y - amount_out_y_bot
            
            # 2. Simulate victim's trade (check slippage)
            amount_out_y_victim = self.cfmm.calculate_amount_out(
                victim_tx.swap_details['amount_in'],
                reserve_x_after_frontrun,
                reserve_y_after_frontrun
            )
            
            if amount_out_y_victim < min_amount_out_victim:
                # This frontrun is too large and would cause the victim's tx to revert.
                # We can stop searching as larger frontruns will also fail.
                break
                
            reserve_x_after_victim = reserve_x_after_frontrun + victim_tx.swap_details['amount_in']
            reserve_y_after_victim = reserve_y_after_frontrun - amount_out_y_victim
            
            # 3. Simulate backrun
            amount_in_y_backrun = amount_out_y_bot
            amount_out_x_bot = self.cfmm.calculate_amount_out(
                amount_in_y_backrun,
                reserve_y_after_victim,
                reserve_x_after_victim
            )
            
            gross_profit_x = amount_out_x_bot - frontrun_x
            
            if gross_profit_x > best_profit:
                best_profit = gross_profit_x
                optimal_frontrun = frontrun_x

        if optimal_frontrun == 0:
            return None

        # --- Calculate total gas cost ---
        # Create dummy transactions for cost calculation
        frontrun_tx_for_cost = Transaction(0, "", 0, CONFIG, 0, 0)
        backrun_tx_for_cost = Transaction(0, "", 0, CONFIG, 0, 0)
        
        # In a competitive PGA, bots bid up priority fees.
        # Simple strategy: bid slightly more than the victim.
        bot_priority_fee = victim_tx.priority_fee_gwei + 0.1
        
        frontrun_tx_for_cost.priority_fee_gwei = bot_priority_fee
        backrun_tx_for_cost.priority_fee_gwei = bot_priority_fee - 0.01 # Backrun can have lower priority
        frontrun_tx_for_cost.max_fee_per_gas = base_fee + bot_priority_fee
        backrun_tx_for_cost.max_fee_per_gas = base_fee + backrun_tx_for_cost.priority_fee_gwei
        
        # Create a dummy bundle to get total cost
        dummy_bundle = Bundle("dummy", [frontrun_tx_for_cost, backrun_tx_for_cost], 0)
        
        # Price of WETH in USDC
        price_x_in_y = self.cfmm.get_reserves() / self.cfmm.get_reserves()
        
        total_gas_cost_eth = self.cost_model.get_bundle_cost(dummy_bundle, base_fee)
        
        # Convert profit to ETH terms (assuming Token X is WETH)
        gross_profit_eth = best_profit
        net_profit_eth = gross_profit_eth - total_gas_cost_eth
        
        return {
            "optimal_frontrun_x": optimal_frontrun,
            "gross_profit_eth": gross_profit_eth,
            "total_gas_cost_eth": total_gas_cost_eth,
            "net_profit_eth": net_profit_eth,
            "bot_priority_fee": bot_priority_fee
        }

    def execute_attack(self, victim_tx: Transaction, profitability: Dict, base_fee: float):
        """Constructs and submits a sandwich bundle."""
        bot_priority_fee = profitability['bot_priority_fee']
        
        frontrun_tx = Transaction(
            tx_id=-self.bot_id, # Negative ID to distinguish bot txs
            sender=f"bot_{self.bot_id}",
            arrival_time=self.clock.current_time,
            gas_limit=CONFIG,
            priority_fee_gwei=bot_priority_fee,
            max_fee_per_gas=base_fee + bot_priority_fee,
            is_swap=True,
            swap_details={
                "amount_in": profitability['optimal_frontrun_x'],
                "token_in": "X",
                "token_out": "Y"
            }
        )
        
        # Backrun priority can be lower, but must be high enough to get in the same block.
        backrun_tx = Transaction(
            tx_id=-self.bot_id - 1000,
            sender=f"bot_{self.bot_id}",
            arrival_time=self.clock.current_time,
            gas_limit=CONFIG,
            priority_fee_gwei=victim_tx.priority_fee_gwei - 0.1, # Just needs to get in the block
            max_fee_per_gas=base_fee + (victim_tx.priority_fee_gwei - 0.1),
            is_swap=True,
            swap_details={
                "amount_in": 0, # This will be filled in by the VM after frontrun
                "token_in": "Y",
                "token_out": "X"
            }
        )
        
        # The bundle needs to have a higher effective gas price than the victim
        # to be ordered correctly by the builder.
        # We achieve this by giving the frontrun a higher priority fee.
        # The backrun is placed after the victim.
        # A real builder would respect bundle atomicity and ordering.
        # Our simple builder will order by effective gas price, so we must ensure
        # frontrun_priority > victim_priority > backrun_priority.
        # For simplicity, we submit a single bundle item and assume the builder
        # knows how to order it around the victim.
        
        # A more realistic model would have the bot submit a bundle of [frontrun, victim, backrun]
        # to a builder that supports it. Our builder is simple, so we submit two separate txs
        # with carefully chosen priorities. Let's adapt to a bundle model.
        
        bundle = Bundle(
            bundle_id=f"sandwich_{victim_tx.tx_id}_by_{self.bot_id}",
            transactions=[frontrun_tx, backrun_tx],
            submit_time=self.clock.current_time
        )
        
        self.mempool.add_bundle(bundle)

# 5.2. The Liquidation Bot Agent (Conceptual Outline)

class LendingProtocol:
    """A placeholder for a simulated lending protocol state."""
    def __init__(self):
        self.loans = # In a real sim, this would contain Loan objects
    def check_health_factors(self):
        # This method would iterate through loans and check their HF against oracle prices.
        # It would return a list of liquidatable loans.
        pass

class LiquidationBot:
    """A conceptual outline for a liquidation bot."""
    def __init__(self, bot_id: int, lending_protocol: LendingProtocol):
        self.bot_id = bot_id
        self.lending_protocol = lending_protocol
        
    def detect_and_execute(self):
        # 1. Listen for Oracle price update events.
        # 2. On update, call self.lending_protocol.check_health_factors().
        # 3. For each liquidatable loan:
        #    a. Calculate profitability using the model from Section 2.2.
        #    b. If profitable, construct a liquidation transaction.
        #    c. Submit the transaction to the mempool with a competitive priority fee.
        pass

# --- Section 6: Experimental Analysis of MEV Economics ---

def run_simulation(config_overrides: Dict = {}) -> Dict:
    """Main simulation loop."""
    global clock # Use a global clock for simplicity in this script
    
    # Apply config overrides for experiments
    sim_config = CONFIG.copy()
    sim_config.update(config_overrides)
    
    set_seed(sim_config)
    
    # --- Initialization ---
    clock = Clock()
    mempool = Mempool()
    cfmm = UniswapV2CFMM(sim_config, sim_config)
    cost_model = SimpleCostModel()
    vm = VirtualMachine(cfmm)
    
    bots =)]
    
    tx_generator = TransactionGenerator(clock, mempool, sim_config)
    
    # Schedule initial events
    tx_generator.start()
    clock.schedule_event(sim_config, "BLOCK_PRODUCTION")
    
    base_fee = sim_config
    
    # --- Simulation Loop ---
    while clock.current_time < sim_config:
        event = clock.next_event()
        if not event:
            break
            
        if event.action == "TX_ARRIVAL":
            event.data.generate_transaction(clock.current_time)
            # Notify bots of the new transaction
            new_tx = mempool.pending_txs[event.data.tx_counter]
            if new_tx.is_swap:
                for bot in bots:
                    bot.detect_and_execute(new_tx, base_fee)

        elif event.action == "BOT_ACTION":
            event.data["bot"].perform_action(event.data["victim_tx"], event.data["base_fee"])

        elif event.action == "BLOCK_PRODUCTION":
            builder = BlockBuilder(mempool, sim_config)
            block, gas_used = builder.build_block(base_fee)
            
            vm.execute_block(block)
            
            # Clear mempool of transactions included in the block
            # A more robust sim would track which txs were included. Here we clear all.
            mempool.clear()
            
            # Update base fee according to EIP-1559
            target_gas = sim_config / 2
            eta = 1/8
            base_fee_change = base_fee * eta * (gas_used - target_gas) / target_gas
            base_fee = max(0, base_fee + base_fee_change)
            
            # Schedule next block
            clock.schedule_event(sim_config, "BLOCK_PRODUCTION")

    return {
        "total_profit": sum(vm.sandwich_profits),
        "num_sandwiches": len(vm.sandwich_profits),
        "avg_profit": np.mean(vm.sandwich_profits) if vm.sandwich_profits else 0
    }

# 6.1. Experiment 1: The Erosion of Sandwich Profits

def run_experiments():
    """Runs the experiments and prints results."""
    print("\n" + "="*50)
    print("RUNNING EXPERIMENT 1A: PROFIT VS. COMPETITION")
    print("="*50)
    
    competition_results =
    bot_counts = 
    for n_bots in bot_counts:
        print(f"\n--- Running simulation with {n_bots} bot(s) ---")
        results = run_simulation({"NUM_SANDWICH_BOTS": n_bots})
        competition_results.append(results['avg_profit'])
        print(f"Result: Avg Profit = {results['avg_profit']:.6f} ETH")

    print("\n" + "="*50)
    print("RUNNING EXPERIMENT 1B: PROFIT VS. GAS PRICE")
    print("="*50)

    congestion_results =
    base_fees = 
    for fee in base_fees:
        print(f"\n--- Running simulation with base fee {fee} Gwei ---")
        # Set a competitive number of bots for this experiment
        results = run_simulation({"INITIAL_BASE_FEE": fee, "NUM_SANDWICH_BOTS": 5})
        congestion_results.append(results['avg_profit'])
        print(f"Result: Avg Profit = {results['avg_profit']:.6f} ETH")
        
    print("\n" + "="*50)
    print("EXPERIMENTAL RESULTS SUMMARY")
    print("="*50)
    print("Avg Profit vs. Number of Bots:")
    for count, profit in zip(bot_counts, competition_results):
        print(f"  {count} Bots: {profit:.6f} ETH")
    
    print("\nAvg Profit vs. Initial Base Fee (Gwei):")
    for fee, profit in zip(base_fees, congestion_results):
        print(f"  {fee} Gwei: {profit:.6f} ETH")
        
    # TODO: Use matplotlib to plot these results for visualization.
    # import matplotlib.pyplot as plt
    # plt.figure(figsize=(12, 5))
    # plt.subplot(1, 2, 1)
    # plt.plot(bot_counts, competition_results, 'o-')
    # plt.title('Profit vs. Competition')
    # plt.xlabel('Number of Sandwich Bots')
    # plt.ylabel('Average Net Profit (ETH)')
    # plt.grid(True)
    #
    # plt.subplot(1, 2, 2)
    # plt.plot(base_fees, congestion_results, 'o-')
    # plt.title('Profit vs. Network Congestion')
    # plt.xlabel('Initial Base Fee (Gwei)')
    # plt.ylabel('Average Net Profit (ETH)')
    # plt.grid(True)
    # plt.tight_layout()
    # plt.show()


# 6.1 (cont.) Unit Tests for Sandwich Bot Logic

class TestSandwichBot(unittest.TestCase):
    def setUp(self):
        """Set up a consistent environment for each test."""
        set_seed(42)
        self.clock = Clock()
        self.mempool = Mempool()
        self.cfmm = UniswapV2CFMM(1000.0, 2000000.0)
        self.cost_model = SimpleCostModel()
        self.bot = SandwichBot(1, self.clock, self.mempool, self.cfmm, self.cost_model)
        self.base_fee = 20.0

    def test_profitability_disappears_with_high_gas(self):
        """Profit should be negative if gas costs exceed gross profit."""
        victim_tx = Transaction(
            tx_id=1, sender="test", arrival_time=0, gas_limit=150000,
            priority_fee_gwei=5.0, max_fee_per_gas=1000, is_swap=True,
            swap_details={"amount_in": 50.0, "token_in": "X", "token_out": "Y", "slippage_tolerance": 0.01}
        )
        # Use a very high base fee to make costs prohibitive
        high_base_fee = 500.0
        profitability = self.bot.calculate_sandwich_profitability(victim_tx, high_base_fee)
        self.assertIsNotNone(profitability)
        self.assertLess(profitability['net_profit_eth'], 0, "Net profit should be negative with high gas costs")

    def test_no_attack_on_unprofitable_trade(self):
        """Bot should not submit a bundle for an unprofitable opportunity."""
        victim_tx = Transaction(
            tx_id=2, sender="test", arrival_time=0, gas_limit=150000,
            priority_fee_gwei=5.0, max_fee_per_gas=30, is_swap=True,
            swap_details={"amount_in": 0.1, "token_in": "X", "token_out": "Y", "slippage_tolerance": 0.01} # Very small trade
        )
        profitability = self.bot.calculate_sandwich_profitability(victim_tx, self.base_fee)
        if profitability is not None:
            self.assertLessEqual(profitability['net_profit_eth'], 0, "Net profit for small trade should be non-positive")
        
        # Check that no bundle is added to the mempool
        initial_bundle_count = len(self.mempool.pending_bundles)
        self.bot.perform_action(victim_tx, self.base_fee)
        self.assertEqual(len(self.mempool.pending_bundles), initial_bundle_count, "Bot should not submit a bundle for unprofitable trade")

    def test_revert_condition_with_large_frontrun(self):
        """Check if the profitability calculation correctly identifies trades that would revert."""
        victim_tx = Transaction(
            tx_id=3, sender="test", arrival_time=0, gas_limit=150000,
            priority_fee_gwei=5.0, max_fee_per_gas=30, is_swap=True,
            swap_details={"amount_in": 20.0, "token_in": "X", "token_out": "Y", "slippage_tolerance": 0.001} # Very tight slippage
        )
        
        # Manually check a large frontrun
        frontrun_x = 30.0 # Larger than victim
        reserve_x, reserve_y = self.cfmm.get_reserves()
        amount_out_victim_no_frontrun = self.cfmm.calculate_amount_out(victim_tx.swap_details['amount_in'], reserve_x, reserve_y)
        min_amount_out_victim = amount_out_victim_no_frontrun * (1 - victim_tx.swap_details['slippage_tolerance'])
        
        amount_out_y_bot = self.cfmm.calculate_amount_out(frontrun_x, reserve_x, reserve_y)
        reserve_x_after_frontrun = reserve_x + frontrun_x
        reserve_y_after_frontrun = reserve_y - amount_out_y_bot
        
        amount_out_y_victim = self.cfmm.calculate_amount_out(
            victim_tx.swap_details['amount_in'],
            reserve_x_after_frontrun,
            reserve_y_after_frontrun
        )
        
        self.assertLess(amount_out_y_victim, min_amount_out_victim, "Large frontrun should push victim past slippage limit")

def run_unit_tests():
    """Runs the unit test suite."""
    print("\n" + "="*50)
    print("RUNNING UNIT TESTS")
    print("="*50)
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TestSandwichBot))
    runner = unittest.TextTestRunner()
    runner.run(suite)


# --- Main Execution ---
if __name__ == "__main__":
    # To run in a Colab notebook or as a script
    
    # Run the experiments
    run_experiments()
    
    # Run the unit tests
    run_unit_tests()

Conclusions and Future DirectionsThis report has established a comprehensive framework for the modeling and simulation of adversarial economics in blockchain mempools.Theoretical Findings:The formal models presented in Part I demonstrate that the complex, emergent behaviors of the MEV ecosystem can be derived from a set of core economic principles and game-theoretic interactions.Centralization from Asymmetry: The separation of public and private order flow is not just a feature of the market but a fundamental driver of builder centralization. The ability to source exclusive order flow creates a powerful feedback loop that leads to an oligopolistic market structure.Mechanism Design as Defense: The mathematical structure of DeFi protocols, particularly the price impact function of an AMM or the design of a liquidation mechanism, acts as a primary determinant of their vulnerability to MEV. This elevates protocol design to a core security consideration, where choices directly influence the economic viability of attacks.Value Accrual to Builders: Game-theoretic analysis of Priority Gas Auctions reveals that for public MEV opportunities, competition among searchers is a value-destructive race to the bottom. The vast majority of the extractable value flows upstream to the block builders who act as auctioneers, solidifying their central role in the MEV supply chain.Simulation and Experimental Validation:The Python laboratory implemented in Part II provides a practical tool for validating these theoretical models and exploring their implications. The initial experiments confirm the core hypotheses: sandwich attack profitability is highly sensitive to both network congestion (gas costs) and direct competition. As the number of competing bots or the base fee increases, the net profit for an attacker rapidly diminishes, illustrating the harsh economic realities of public MEV extraction. The provided unit tests further validate the correctness of the core profitability logic.Future Directions:This framework is designed as a foundational and extensible platform. Future work should focus on several key areas:Integration of Real-World Data: The simulator is architected to allow for the replay of historical mempool data. Integrating real transaction traces would enable the backtesting of more sophisticated adversarial strategies and provide a higher-fidelity environment for research.Expanding the Strategy Library: The current implementation focuses on sandwich attacks. The framework can be extended to include other critical MEV strategies, such as arbitrage across multiple CFMMs and the implementation of the conceptual liquidation bot.Modeling More Complex Builder Behavior: The current block builder uses a simple greedy heuristic. Future iterations could incorporate more advanced packing algorithms and model the strategic bidding behavior of builders in the MEV-Boost auction, as formalized in Section 1.3.Cross-Domain MEV: As the blockchain ecosystem evolves, MEV is increasingly extracted across different domains (e.g., between L1 and L2s). The simulation could be extended to model multiple interconnected state machines to study these more complex forms of value extraction.In conclusion, the interplay of mempool dynamics, auction theory, and strategic agent behavior creates a rich and adversarial economic landscape. The combination of rigorous formal modeling and high-fidelity simulation, as presented in this report, provides a powerful methodology for understanding, predicting, and ultimately mitigating the negative externalities of MEV.