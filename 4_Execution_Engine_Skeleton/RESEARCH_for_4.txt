A Theoretical and Practical Framework for a Secure Algorithmic Execution EnginePart A: Theoretical Foundations and System DesignCode snippet\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{caption}
\usepackage{hyperref}

\geometry{a4paper, margin=1in}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\title{A Theoretical and Practical Framework for a Secure Algorithmic Execution Engine}
\author{Quantitative Research and Development Division}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{A Formal Model of the Limit Order Book and Execution Semantics}
The Limit Order Book (LOB) is the central mechanism in modern electronic financial markets, aggregating the intentions of buyers and sellers to facilitate price discovery and trade. A rigorous, formal model of the LOB is the prerequisite for designing and analyzing any execution strategy. This section establishes the mathematical representation of the LOB, models its stochastic dynamics, and formally defines the semantics of common order types that an execution engine uses to interact with it.

\subsection{Mathematical Representation of the LOB State}
At any discrete time point $t$, the state of the LOB, denoted $\mathcal{L}_t$, is a snapshot of all resting (unexecuted) limit orders. It is fundamentally a data structure composed of two distinct sides: the bid side, containing orders to buy, and the ask side, containing orders to sell.

Let $P$ be the set of discrete price levels, determined by the instrument's tick size. The state $\mathcal{L}_t$ can be formally represented as a tuple of two ordered sets:
$$\mathcal{L}_t = (\mathcal{B}_t, \mathcal{A}_t)$$
where:
\begin{itemize}
    \item $\mathcal{B}_t = \{(p_i^b, v_i^b)\}_{i=1}^{N_b}$ is the set of $N_b$ bid price levels and their corresponding aggregated volumes, ordered such that $p_1^b > p_2^b > \dots > p_{N_b}^b$.
    \item $\mathcal{A}_t = \{(p_j^a, v_j^a)\}_{j=1}^{N_a}$ is the set of $N_a$ ask price levels and their corresponding aggregated volumes, ordered such that $p_1^a < p_2^a < \dots < p_{N_a}^a$.
\end{itemize}
The highest bid price, or \textbf{best bid}, is $p_t^* = p_1^b$. The lowest ask price, or \textbf{best ask}, is $a_t^* = p_1^a$. The difference, $S_t = a_t^* - p_t^*$, is the bid-ask spread. For a valid LOB state, it is required that $p_t^* < a_t^*$.

A critical feature of the LOB is the priority rule for execution. Orders are prioritized first by price (price priority) and then by time of submission (time priority) for orders at the same price level.[2] To capture this, the aggregated volume $v$ at a price level $p$ must be modeled not as a scalar, but as an ordered queue of individual order sizes:
$$Q_p(t) = [q_1, q_2, \dots, q_k]$$
where $q_1$ is the oldest (highest priority) order at that price level, and $\sum_{i=1}^{k} q_i = v_p(t)$. When a market order arrives, it consumes liquidity from the front of this queue. A new passive limit order of size $q_{new}$ is appended to the back of the queue: $Q_p(t+\Delta t) = [q_1, \dots, q_k, q_{new}]$. This queueing representation is essential for accurately modeling the probability and time-to-fill for a limit order, as its position in the queue determines the volume ahead of it that must be executed first.

\begin{table}[h!]
\centering
\caption{Mathematical Notation for LOB Modeling}
\label{tab:lob_notation}
\begin{tabular}{@{}ll@{}}
\toprule
Symbol & Definition \\ \midrule
$\mathcal{L}_t$ & State of the Limit Order Book at time $t$. \\
$\mathcal{B}_t$ & The set of bid price-volume pairs (the bid book). \\
$\mathcal{A}_t$ & The set of ask price-volume pairs (the ask book). \\
$p_i^b, v_i^b$ & The $i$-th best bid price and its aggregated volume. \\
$p_j^a, v_j^a$ & The $j$-th best ask price and its aggregated volume. \\
$p_t^*$ & The best bid price at time $t$. \\
$a_t^*$ & The best ask price at time $t$. \\
$S_t$ & The bid-ask spread at time $t$, $S_t = a_t^* - p_t^*$. \\
$Q_p(t)$ & An ordered queue of individual order sizes at price level $p$ at time $t$. \\
$\lambda_t^{LO}, \lambda_t^{MO}, \lambda_t^{C}$ & Arrival rates (intensities) of limit orders, market orders, and cancellations. \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Modeling LOB Dynamics as a Stochastic Process}
The LOB state $\mathcal{L}_t$ evolves stochastically over time due to three fundamental event types: the submission of new limit orders (LO), the submission of market orders (MO) that consume liquidity, and the cancellation (C) of existing limit orders.[3] The choice of model for these event arrivals represents a critical trade-off between analytical tractability and empirical realism.[3]

For a theory-first approach aimed at optimal control formulations, tractable models are preferred. These models allow for the derivation of state transition probabilities, which are essential for dynamic programming solutions.
\begin{itemize}
    \item \textbf{Markovian Queueing Models:} A powerful simplification is to model the LOB as a continuous-time Markov process.[4, 5] In this framework, the state is defined by the volumes at a finite number of price levels around the spread. The arrivals of limit orders, market orders, and cancellations are modeled as independent Poisson processes. This turns the LOB into a multi-dimensional birth-death process, where state transitions correspond to order book events.[4] While this approach makes simplifying assumptions (e.g., constant order sizes, memoryless arrivals), it is analytically tractable and can capture first-order LOB dynamics.
    \item \textbf{Point Process Models:} A more general and flexible framework models the order flow as a marked point process.[6] Each point in time corresponds to an event, and the "mark" contains the event's characteristics (e.g., type, price, size). This allows for more complex dynamics, such as self-exciting processes (e.g., Hawkes processes) that can capture the empirically observed clustering of trading activity.[1, 7]
\end{itemize}
The selection of a tractable model like a Markovian queueing system is not merely a matter of convenience; it is a foundational decision that enables the use of classical optimal control theory, such as Hamilton-Jacobi-Bellman (HJB) equations, for solving the execution problem. More complex, data-driven generative models, such as those using Recurrent Neural Networks [3], offer greater realism but do not yield the explicit state transition dynamics required for HJB methods. Such models are better suited as environments for training reinforcement learning agents, which represents a different, albeit powerful, solution paradigm.[8]

\subsection{Formal Definitions and Execution Semantics of Order Types}
The execution engine interacts with the LOB through a discrete set of order types, each with precise execution semantics.[9, 10, 11] Understanding these semantics is crucial for predicting the outcome of an action. Let the agent wish to place an order of type $\omega$ with volume $V$ and, if applicable, a limit price $p_L$.

\begin{itemize}
    \item \textbf{Market Order ($\omega = \text{Market}$):} An instruction to buy or sell volume $V$ immediately at the best available price(s). A buy market order executes against the ask book $\mathcal{A}_t$, starting at $a_t^* = p_1^a$ and "walking the book" to higher prices until the volume $V$ is filled. The execution is guaranteed as long as sufficient volume exists in the book, but the price is not.[2, 9] The resulting execution price is the volume-weighted average of all fills. This order type prioritizes certainty of execution over price control.
    \item \textbf{Limit Order ($\omega = \text{Limit}$):} An instruction to buy at a price $p \le p_L$ or sell at a price $p \ge p_L$.
    \begin{itemize}
        \item If the order is \textit{marketable} (e.g., a buy with $p_L \ge a_t^*$), it behaves like a market order, consuming liquidity up to its limit price $p_L$. Any unfilled portion becomes a passive limit order at $p_L$.
        \item If the order is \textit{passive} (e.g., a buy with $p_L < a_t^*$), it is added to the LOB at price $p_L$ and placed at the back of the queue $Q_{p_L}(t)$. Execution is not guaranteed and is subject to uncertain waiting times.[2, 12] This order type prioritizes price control over certainty of execution.
    \end{itemize}
    \item \textbf{Immediate-Or-Cancel ($\omega = \text{IOC}$):} A limit order with the additional constraint that any portion of the order that cannot be filled immediately upon submission is cancelled.[10, 13] It never rests on the LOB. This is used to probe for available liquidity at a specific price or better without leaving a passive order.
    \item \textbf{Fill-Or-Kill ($\omega = \text{FOK}$):} A limit order that must be executed in its entirety immediately, or it is cancelled completely.[10, 11] This is used when partial fills are unacceptable.
    \item \textbf{Post-Only ($\omega = \text{PostOnly}$):} A limit order that is only accepted by the exchange if it would be passive (i.e., it would not immediately match with an existing order). If the order would cross the spread and execute, it is rejected or repriced by the exchange. This guarantees the trader acts as a liquidity provider (a "maker"), often qualifying for a fee rebate.[14]
\end{itemize}

\begin{table}[h!]
\centering
\caption{Order Type Execution Semantics}
\label{tab:order_semantics}
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}lllll@{}}
\toprule
\textbf{Order Type} & \textbf{Execution Guarantee} & \textbf{Price Guarantee} & \textbf{LOB Interaction} & \textbf{Primary Use Case} \\ \midrule
\textbf{Market} & High (if liquidity exists) & None (subject to slippage) & Consumes liquidity (taker) & Urgency, certainty of execution \\
\textbf{Limit} & None (if passive) & At limit price or better & Adds liquidity (maker) if passive & Price control, patience \\
\textbf{IOC} & Partial or full, immediate & At limit price or better & Consumes liquidity, never rests & Probe for liquidity without commitment \\
\textbf{FOK} & All or none, immediate & At limit price or better & Consumes liquidity, never rests & Avoid partial fills \\
\textbf{Post-Only} & None & At specified limit price & Adds liquidity, rejected if taker & Guarantee maker status for fee benefits \\ \bottomrule
\end{tabular}%
}
\end{table}

\section{The Optimal Execution Problem}
The central task of the execution engine is to solve the optimal execution problem: how to transact a large parent order over a period of time to minimize total costs. This requires a formal definition of these costs and a well-posed mathematical optimization problem that balances the trade-offs inherent in different execution strategies.

\subsection{Modeling Transaction Costs}
Transaction costs are broadly categorized into explicit and implicit costs. A comprehensive model must account for both to accurately reflect the true cost of trading.[15, 16] The Implementation Shortfall framework provides a holistic measure, defined as the difference between the value of the position at the time of the trading decision and the final cash value realized after the execution is complete.[16, 17]

\begin{itemize}
    \item \textbf{Explicit Costs:} These are direct, observable costs, primarily commissions and exchange fees. They can be modeled as a function of the traded value or volume.
    \item \textbf{Implicit Costs:} These costs arise from the interaction of the order with the market.
    \begin{itemize}
        \item \textbf{Market Impact Cost:} The adverse price movement caused by the trading activity itself. This is the cost of demanding liquidity. Following the Almgren-Chriss framework, it can be decomposed into two components [18, 19]:
        \begin{itemize}
            \item \textit{Permanent Impact:} A permanent shift in the equilibrium price caused by the information conveyed by the trade. It is typically modeled as a linear function of the trading rate.
            \item \textit{Temporary Impact:} A transient price concession required to incentivize counterparties to trade, from which the price recovers after the trade. It is often modeled as a non-linear (e.g., power-law) function of the trading rate.
        \end{itemize}
        \item \textbf{Timing Risk / Opportunity Cost:} The risk that the market price will move adversely while the trader is waiting to execute a passive strategy.[15, 20] This is the cost of delaying execution and is typically measured by the variance of the execution cost.
        \item \textbf{Spread Cost:} The cost incurred by aggressive orders that must cross the bid-ask spread to execute.[16]
    \end{itemize}
\end{itemize}

\subsection{The Execution Decision Problem: A Formal Statement}
The objective is to liquidate (or acquire) a total quantity of $X$ shares over a finite time horizon $$. The time horizon is discretized into $N$ steps, $t_0, t_1, \dots, t_N=T$. At each step $t_i$, the agent chooses an order (type $\omega_i$, size $v_i$) to submit. The sequence of actions $\{\omega_i, v_i\}_{i=0}^{N-1}$ constitutes the trading strategy.

A standard and powerful formulation is the \textbf{mean-variance optimization} framework, which seeks to minimize a weighted sum of the expected execution cost and its variance.[20, 21] Let $\mathcal{C}(\{\omega_i, v_i\})$ be the total implementation shortfall (a random variable). The optimization problem is:
$$\min_{\{\omega_i, v_i\}_{i=0}^{N-1}} \mathbb{E}[\mathcal{C}] + \lambda \cdot \text{Var}[\mathcal{C}]$$
subject to the constraints:
\begin{enumerate}
    \item \textbf{Terminal Constraint:} $\sum_{i=0}^{N-1} v_i^{fill} = X$, where $v_i^{fill}$ is the filled quantity from the order placed at time $t_i$.
    \item \textbf{Fill Probability Constraint:} For strategies involving passive orders, one might impose a minimum probability of completion: $P(\sum v_i^{fill} = X) \ge 1 - \epsilon$. The fill probability for a limit order can be estimated using survival analysis models that depend on queue position, spread, volatility, and other market variables.[2]
\end{enumerate}
The parameter $\lambda \ge 0$ represents the trader's risk aversion. A higher $\lambda$ places more weight on minimizing the variance (risk) of the cost, typically leading to faster, more aggressive execution strategies to reduce exposure to market volatility. A lower $\lambda$ focuses on minimizing expected impact costs, leading to slower, more passive strategies.

\subsection{Convexity and Relaxation via Dynamic Programming}
The true optimal execution problem, with its stochastic and non-linear market dynamics, is generally non-convex, making it computationally intractable to find a guaranteed global optimum.[20] A common approach is to solve a simplified, convex version of the problem.

The mean-variance objective is time-inconsistent, which complicates a direct application of dynamic programming. However, it can be embedded within a time-consistent, linear-quadratic (LQ) stochastic control framework.[22] This is achieved through a technique known as \textit{quadratic scalarization}.[20] Instead of directly minimizing the mean-variance objective, we solve a related problem of minimizing the expected squared deviation from a parameterized target wealth level. The value function $V(t, x, S)$ at time $t$ with $x$ shares remaining and stock price $S$ can be found by solving the Hamilton-Jacobi-Bellman (HJB) partial differential equation backwards in time from $T$:
$$\frac{\partial V}{\partial t} + \sup_{v_t} \left\{ \mathcal{A}^{v_t} V(t, x, S) \right\} = 0$$
where $\mathcal{A}^{v_t}$ is the infinitesimal generator of the controlled state process $(x_t, S_t)$ under trading rate $v_t$. The solution to this HJB equation characterizes the optimal trading strategy.[22, 23, 24]

It is a crucial and often overlooked nuance that the classic Almgren-Chriss model, while foundational, is not strictly optimal under a mean-variance (MV) framework. Instead, it is the solution to a mean-quadratic variation (MQV) problem.[20, 21] MV optimization penalizes the variance of the final wealth, a measure of total risk over the horizon. MQV optimization penalizes the path-wise volatility of the portfolio's value during the execution. While related, these objectives can lead to substantially different strategies. An MV-optimal strategy might accept high intra-horizon risk if it expects to hedge it away by the terminal time, whereas an MQV-optimal strategy would penalize such path-dependent risk. Acknowledging this distinction is vital for a robust theoretical understanding and for correctly interpreting the behavior of implemented strategies based on this literature.

\begin{table}[h!]
\centering
\caption{Optimal Execution Problem Formulation}
\label{tab:problem_formulation}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Component} & \textbf{Formal Definition} \\ \midrule
\textbf{Objective Function} & Minimize Mean-Variance of Implementation Shortfall: \\
& $\mathbb{E}[\mathcal{C}] + \lambda \cdot \text{Var}[\mathcal{C}]$ \\
\textbf{Decision Variables} & Sequence of orders: $\{\omega_t, v_t\}$ (Order type and size at each time step). \\
\textbf{State Variables} & Time $t$, Remaining Inventory $x_t$, Asset Price $S_t$, LOB State $\mathcal{L}_t$. \\
\textbf{Constraints} & 1. Terminal Inventory: $\sum v_t^{fill} = X$. \\
& 2. Fill Probability (optional): $P(\sum v_t^{fill} = X) \ge 1 - \epsilon$. \\
\textbf{Key Parameters} & Risk Aversion $\lambda$, Time Horizon $T$, Total Quantity $X$. \\ \bottomrule
\end{tabular}
\end{table}

\section{Principles of Post-Trade System Safety and Integrity}
An execution engine's theoretical optimality is irrelevant if its real-world implementation is not robust. Post-trade safety checks are essential for ensuring operational integrity, preventing catastrophic errors, and maintaining a consistent state with the exchange. These principles form a layered defense system against software bugs, network failures, and unexpected market behavior.

\subsection{Fill Validation and Reconciliation}
The engine's internal state (open orders, positions, balances) must be an exact, real-time mirror of its state at the exchange. Any divergence can lead to incorrect risk calculations and flawed execution decisions. Fill validation and reconciliation are the two core processes that maintain this consistency.[25, 26, 27]

\begin{itemize}
    \item \textbf{Fill Validation:} This is an immediate, event-driven process triggered upon receiving a trade execution notification from the exchange. The system must perform a series of fundamental checks to prove the validity of the fill before updating its internal state [25]:
    \begin{itemize}
        \item \textbf{Order Existence:} Does the fill's order identifier correspond to a known, active order within the engine?
        \item \textbf{Quantity Check:} Is the filled quantity less than or equal to the remaining open quantity for that order?
        \item \textbf{Price Check:} Is the fill price compliant with the order's terms (e.g., for a buy limit order, is fill price $\le$ limit price)?
        \item \textbf{Instrument Check:} Does the asset in the fill match the asset of the order?
    \end{itemize}
    A fill failing any of these checks indicates a critical error and must trigger an immediate alert and halt the strategy.

    \item \textbf{Reconciliation:} This is a periodic, state-based process. The engine must regularly (e.g., every few seconds) poll the exchange's API for a complete list of its current open orders and positions. This external state, considered the "source of truth," is then compared against the engine's internal state representation. Any discrepancies (e.g., an order the engine believes is open but the exchange reports as cancelled or filled) must be identified. The reconciliation process should then log the discrepancy, raise an alert, and, for non-ambiguous cases, update the internal state to match the exchange's state.[27]
\end{itemize}

\subsection{Idempotency Guarantees for Command Integrity}
In distributed systems, operations may be retried due to network timeouts or other transient failures. An operation is \textbf{idempotent} if performing it multiple times has the same effect as performing it once.[28, 29] For financial transactions, idempotency is not a feature but a strict requirement to prevent catastrophic errors like duplicate order submissions.

The standard implementation pattern involves the client generating a unique \textbf{idempotency key} (e.g., a UUID) for every state-changing request (place order, cancel order).[28, 30] This key is sent with the request. The server (the exchange) records the key upon successful processing of the request. If a subsequent request arrives with the same key, the server does not re-execute the operation but instead returns the stored result of the original operation.[31] This allows the client to safely retry requests without fear of unintended side effects.

Exchanges like Kraken facilitate this through parameters such as `userref` or `cl_ord_id` on their order submission endpoints.[32, 33] The execution engine \textit{must} generate and use a unique identifier for every single order submission and cancellation request to leverage this critical safety feature.

\subsection{Risk Management Framework for Leveraged Positions}
Automated risk controls are the final and most critical layer of defense, designed to prevent large losses from algorithm malfunction or extreme market conditions.[34, 35] These controls must operate automatically and without human intervention. They are often mandated by regulations such as MiFID II's RTS 6.[35]

\begin{itemize}
    \item \textbf{Pre-Trade Controls:} Checks performed by the engine \textit{before} an order is dispatched to the exchange.[35]
    \begin{itemize}
        \item \textbf{Maximum Order Size/Value:} An absolute limit on the notional value or quantity of any single order.
        \item \textbf{Price Reasonability ("Fat-Finger") Check:} Rejects orders with a limit price that deviates from the current market price by more than a predefined percentage.
        \item \textbf{Position Limit Check:} Rejects any order that would cause the resulting position to exceed the portfolio-level limits.
    \end{itemize}
    \item \textbf{Post-Trade Controls:} Real-time monitoring of the overall portfolio state.[35]
    \begin{itemize}
        \item \textbf{Maximum Position Limits:} A hard limit on the total long or short exposure (in units of asset or notional value) that the strategy is allowed to hold.[34, 36]
        \item \textbf{Maximum Drawdown Controls:} A "kill switch" mechanism. The system continuously calculates the unrealized profit and loss (P\&L) of the current position. If the P\&L drops below a certain threshold from its peak (e.g., a 5\% drawdown), the system automatically cancels all open orders and liquidates the current position via market orders to prevent further losses.[36]
        \item \textbf{Margin and Leverage Monitoring:} For leveraged positions, the engine must continuously monitor the account's margin level. If the margin utilization approaches a critical threshold (i.e., near the maintenance margin level), the system must trigger an automated risk-reduction routine to avoid a forced liquidation by the exchange, which typically occurs at unfavorable prices.
    \end{itemize}
\end{itemize}
These safety mechanisms—idempotency, reconciliation, and risk limits—are not isolated features but form an interdependent, layered defense. For instance, a failure in idempotency might lead to a duplicate order. This should be caught by the reconciliation process. If both fail, the resulting oversized position should be caught by the post-trade position limit, triggering a system halt. This defense-in-depth approach is fundamental to building a secure and reliable trading system.

\section{A Framework for System Verification and Validation}
Rigorous testing is paramount to ensure the execution engine behaves according to its theoretical specification and safety principles. The testing framework must be ableto validate the system's logic against a controlled, repeatable, and realistic simulation of the exchange environment.[37, 38]

\subsection{Testing Philosophy: From Units to the Integrated System}
A multi-layered testing strategy is required to build confidence in the system's correctness.
\begin{itemize}
    \item \textbf{Unit Testing:} Focuses on testing individual software components (e.g., a single function or class) in isolation to verify their internal logic.
    \item \textbf{Integration Testing:} Verifies the interaction and data flow between different components, such as the `ExecutionEngine` and the `MockKrakenAPI`.[39, 40] This is the most critical phase for validating the core order lifecycle and safety logic.
    \item \textbf{System Testing (Backtesting):} Involves running the entire strategy on historical market data to evaluate its performance and behavior over extended periods. This requires a sophisticated backtesting engine that can replay market data with high fidelity and avoid look-ahead bias.[41]
\end{itemize}
A key component of this philosophy is the development of a test environment that is a high-fidelity replica of the production environment. Best practices involve using CI/CD pipelines to automatically spin up clean, isolated, "production-like" test environments for each test run, execute the test suite, and tear down the environment.[38] This ensures that tests are deterministic, repeatable, and not influenced by the state of previous test runs. Furthermore, the test environment and mock API must support \textbf{fault injection}—the ability to deliberately introduce errors (e.g., network timeouts, API error responses) to verify the robustness of the engine's error handling and recovery logic.[42]

\subsection{Essential Integration Tests}
The following checklist constitutes the minimum set of integration tests that the system must pass before it can be considered for deployment with live capital. These tests validate the core functionality and safety mechanisms of the engine.

\begin{small}
\begin{longtable}{@{}p{0.05\linewidth}p{0.15\linewidth}p{0.35\linewidth}p{0.35\linewidth}@{}}
\caption{Integration Test Suite} \label{tab:integration_tests} \\
\toprule
\textbf{ID} & \textbf{Category} & \textbf{Scenario Description} & \textbf{Expected Outcome} \\ \midrule
\endfirsthead
\multicolumn{4}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\toprule
\textbf{ID} & \textbf{Category} & \textbf{Scenario Description} & \textbf{Expected Outcome} \\ \midrule
\endhead
\bottomrule
\endfoot
L-01 & Lifecycle & Place a limit buy order below the market. Simulate a market move that fills the order completely. & Order state transitions from `Pending` to `Open` to `Closed`. Position and balance are updated correctly. \\
L-02 & Lifecycle & Place a limit sell order. Simulate a partial fill. Then, send a cancellation request. & Order state transitions to `PartiallyFilled`. The remaining volume is cancelled. Position reflects the partial fill. \\
L-03 & Lifecycle & Attempt to cancel a fully filled order. & The cancellation request is rejected by the mock API with an appropriate error. The engine logs the error and maintains the `Closed` state. \\
L-04 & Lifecycle & Submit a Post-Only buy order at a price that would cross the spread. & The mock API rejects the order. The engine's internal state shows no open order. \\
\midrule
I-01 & Idempotency & Send a `place_order` request with a specific `userref`. Send the exact same request again. & The first request creates an order. The second request does not create a new order and returns the success response of the first request. \\
I-02 & Idempotency & Send a `cancel_order` request. Simulate a network timeout. Send the same cancellation request again with the same `userref`. & The order is cancelled exactly once. The second request returns the success response of the first cancellation. \\
\midrule
R-01 & Reconciliation & Engine has an order internally marked as `Open`. Manually change the mock API's state to show this order as `Cancelled`. Trigger reconciliation. & The reconciliation routine detects the mismatch. The engine updates its internal order state to `Cancelled` and logs the event. \\
R-02 & Reconciliation & Manually add an "orphan" order to the mock API's state that does not exist in the engine. Trigger reconciliation. & The routine detects the orphan order and raises a critical alert, as this indicates a major state divergence. \\
\midrule
RM-01 & Risk Mgmt & Attempt to place an order with a quantity exceeding the configured `max_order_size`. & The order is rejected internally by the engine's pre-trade checks. No call is made to the mock API. \\
RM-02 & Risk Mgmt & Place orders to build a position up to 99\% of the `max_position_limit`. Attempt to place another order that would breach the limit. & The final order is rejected by the pre-trade position check. \\
RM-03 & Risk Mgmt & Establish a position. Simulate a market price drop that triggers the `max_drawdown_limit`. & The engine's "kill switch" is activated: it automatically cancels all open orders for the asset and sends a market order to liquidate the entire position. \\
\midrule
E-01 & Error Handling & Configure mock API to return an "Insufficient Funds" error on an order placement attempt. & The engine correctly parses the error, logs it, and does not update its internal state to reflect an open order. \\
E-02 & Error Handling & Configure mock API to return a rate limit error. & The engine should back off for the required time and then retry the request. \\
E-03 & Error Handling & Make the mock API unresponsive (simulate network failure). & The engine should handle the connection timeout gracefully, attempt to reconnect according to its policy, and not enter an inconsistent state. \\
\end{longtable}
\end{small}

\end{document}
Part B: Colab-Ready Python Implementation SkeletonPython#
# Part B: Colab-Ready Python Implementation Skeleton
#
# This code provides a foundational skeleton for a secure execution engine.
# It includes:
# 1. A MockKrakenAPI to simulate the exchange environment for testing.
# 2. An ExecutionEngine class to manage order lifecycle, state, and risk.
# 3. Unit tests to verify core functionality and safety mechanisms.
# 4. A dry-run mode for safe testing of execution logic.
#
# This skeleton is designed to be extended with sophisticated execution algorithms
# based on the theoretical principles outlined in Part A.
#

import unittest
import time
import uuid
import logging
from collections import deque
from copy import deepcopy
from enum import Enum

# --- Basic Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Data Structures and Enums ---

class OrderStatus(Enum):
    PENDING = "pending"
    OPEN = "open"
    CLOSED = "closed"
    CANCELED = "canceled"
    PARTIALLY_FILLED = "partially_filled"
    REJECTED = "rejected"

class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    IOC = "ioc"
    FOK = "fok"
    POST_ONLY = "post_only"

class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"

# --- Mock Exchange API Layer ---

class MockKrakenAPI:
    """
    A stateful mock of the Kraken API to facilitate deterministic testing.
    Simulates order book, fills, idempotency, and error conditions.
    """
    def __init__(self):
        self.orders = {}  # {order_id: order_details}
        self.processed_userrefs = {} # {userref: response}
        self.balances = {"USD": 100000.0, "BTC": 10.0}
        self.positions = {"BTC": 10.0}
        self.order_id_counter = 1000
        
        # Simple LOB simulation: deque of (price, volume)
        self.bids = deque([ (29999.0, 5.0), (29998.0, 10.0) ])
        self.asks = deque([ (30001.0, 8.0), (30002.0, 12.0) ])

        # For fault injection
        self.error_mode = None
        self.rate_limit_until = 0

    def get_best_ask(self):
        return self.asks if self.asks else float('inf')

    def get_best_bid(self):
        return self.bids if self.bids else 0.0

    def _generate_order_id(self):
        self.order_id_counter += 1
        return f"O-{self.order_id_counter}"

    def add_order(self, pair, side, order_type, volume, price=None, userref=None, oflags=None):
        """Simulates the AddOrder endpoint."""
        # --- Idempotency Check ---
        if userref and userref in self.processed_userrefs:
            logging.warning(f"Idempotency key {userref} already processed. Returning original response.")
            return self.processed_userrefs[userref]

        # --- Error Simulation ---
        if self.error_mode == "INSUFFICIENT_FUNDS":
            return {"error": ["EOrder:Insufficient funds"], "result": {}}
        if time.time() < self.rate_limit_until:
            return {"error":, "result": {}}

        # --- Basic Validation ---
        if side == OrderSide.SELL and self.balances.get(pair.split('/'), 0) < volume:
            return {"error": ["EOrder:Insufficient funds"], "result": {}}

        order_id = self._generate_order_id()
        order = {
            "id": order_id,
            "userref": userref,
            "pair": pair,
            "side": side,
            "type": order_type,
            "volume": volume,
            "volume_executed": 0.0,
            "price": price,
            "status": OrderStatus.OPEN,
            "timestamp": time.time(),
            "oflags": oflags
        }
        
        # --- Post-Only Logic ---
        if order_type == OrderType.POST_ONLY:
            if (side == OrderSide.BUY and price >= self.get_best_ask()) or \
               (side == OrderSide.SELL and price <= self.get_best_bid()):
                order["status"] = OrderStatus.REJECTED
                logging.info(f"Post-only order {order_id} rejected as it would cross the spread.")
                self.orders[order_id] = order
                response = {"error": ["EOrder:Post-only order would execute"], "result": {}}
                if userref: self.processed_userrefs[userref] = response
                return response

        self.orders[order_id] = order
        logging.info(f"MockAPI: Order {order_id} received and is OPEN.")
        
        # --- Simulate Immediate Fills for Market Orders ---
        if order_type == OrderType.MARKET:
            self._match_order(order_id)

        response = {"error":, "result": {"txid": [order_id], "descr": {"order": f"{side.value} {volume} {pair} @ {order_type.value}"}}}
        if userref: self.processed_userrefs[userref] = response
        return response

    def _match_order(self, order_id):
        """A simple matching engine simulation."""
        order = self.orders.get(order_id)
        if not order or order["status"]!= OrderStatus.OPEN:
            return

        volume_to_fill = order["volume"] - order["volume_executed"]
        
        if order["side"] == OrderSide.BUY:
            while volume_to_fill > 0 and self.asks:
                best_ask_price, best_ask_vol = self.asks
                
                if order["price"] is not None and best_ask_price > order["price"]:
                    break # Limit price reached

                fill_vol = min(volume_to_fill, best_ask_vol)
                order["volume_executed"] += fill_vol
                volume_to_fill -= fill_vol
                
                self.asks = (best_ask_price, best_ask_vol - fill_vol)
                if self.asks <= 0:
                    self.asks.popleft()
                
                logging.info(f"MockAPI: Order {order_id} filled {fill_vol} @ {best_ask_price}")

        # (A similar block for SELL side would be implemented here)

        if order["volume_executed"] >= order["volume"]:
            order["status"] = OrderStatus.CLOSED
        elif order["volume_executed"] > 0:
            order["status"] = OrderStatus.PARTIALLY_FILLED
        
        # Update balances on fill
        base_ccy, quote_ccy = order['pair'].split('/')
        if order['side'] == OrderSide.BUY:
            self.balances[base_ccy] = self.balances.get(base_ccy, 0) + order["volume_executed"]
            # Price is simplified here; a real implementation would use actual fill prices
            self.balances[quote_ccy] -= order["volume_executed"] * (order['price'] or self.get_best_bid())
        # (Sell side balance update)
        
    def cancel_order(self, order_id, userref=None):
        """Simulates the CancelOrder endpoint."""
        if userref and userref in self.processed_userrefs:
            return self.processed_userrefs[userref]
            
        order = self.orders.get(order_id)
        if not order:
            return {"error": ["EOrder:Unknown order"], "result": {}}
        if order["status"] in:
            return {"error": ["EOrder:Order already closed"], "result": {}}

        order["status"] = OrderStatus.CANCELED
        logging.info(f"MockAPI: Order {order_id} CANCELED.")
        response = {"error":, "result": {"count": 1}}
        if userref: self.processed_userrefs[userref] = response
        return response

    def get_open_orders(self):
        """Simulates the OpenOrders endpoint."""
        open_orders = {oid: o for oid, o in self.orders.items() if o["status"] in}
        return {"error":, "result": {"open": open_orders}}

# --- Core Execution Engine ---

class ExecutionEngine:
    def __init__(self, api_client, config):
        self.api = api_client
        self.config = config
        
        # Internal State
        self.orders = {} # {internal_id: order_details}
        self.positions = {} # {asset: size}
        self.balances = {} # {asset: amount}
        self.internal_id_counter = 0

    def _generate_internal_id(self):
        self.internal_id_counter += 1
        return f"INT-{self.internal_id_counter}"

    def place_order(self, pair, side, order_type, volume, price=None, oflags=None):
        """Places an order after performing pre-trade risk checks."""
        # --- 1. Pre-trade Risk Checks ---
        if volume > self.config.get("max_order_size", float('inf')):
            logging.error(f"Order rejected: Volume {volume} exceeds max_order_size.")
            return None
        
        # (Add other pre-trade checks here: fat-finger, position limits, etc.)

        # --- 2. Generate Idempotency Key ---
        userref = str(uuid.uuid4())
        internal_id = self._generate_internal_id()
        
        order_details = {
            "internal_id": internal_id,
            "exchange_id": None,
            "userref": userref,
            "status": OrderStatus.PENDING,
            "pair": pair,
            "side": side,
            "type": order_type,
            "volume": volume,
            "price": price,
            "oflags": oflags
        }
        self.orders[internal_id] = order_details
        
        # --- 3. Dry-Run Mode Check ---
        if self.config.get("dry_run", False):
            logging.info(f" Would place order: {order_details}")
            # Simulate a successful submission for testing flows
            order_details["status"] = OrderStatus.OPEN 
            order_details["exchange_id"] = f"DRY-RUN-{self._generate_internal_id()}"
            return internal_id

        # --- 4. Send to API ---
        logging.info(f"Placing order {internal_id} with userref {userref}")
        response = self.api.add_order(pair, side, order_type, volume, price, userref, oflags)

        # --- 5. Handle Response ---
        if response["error"]:
            logging.error(f"API error on order placement: {response['error']}")
            self.orders[internal_id]["status"] = OrderStatus.REJECTED
            return None
        else:
            exchange_id = response["result"]["txid"]
            self.orders[internal_id]["exchange_id"] = exchange_id
            self.orders[internal_id]["status"] = OrderStatus.OPEN
            logging.info(f"Order {internal_id} placed successfully with exchange ID {exchange_id}")
            return internal_id

    def cancel_order(self, internal_id):
        """Cancels an open order."""
        order = self.orders.get(internal_id)
        if not order or not order["exchange_id"]:
            logging.error(f"Cannot cancel order {internal_id}: not found or no exchange ID.")
            return False
        
        if self.config.get("dry_run", False):
            logging.info(f" Would cancel order: {order}")
            order["status"] = OrderStatus.CANCELED
            return True

        response = self.api.cancel_order(order["exchange_id"])
        if response["error"]:
            logging.error(f"API error on order cancellation: {response['error']}")
            return False
        else:
            order["status"] = OrderStatus.CANCELED
            logging.info(f"Order {internal_id} (exchange ID {order['exchange_id']}) cancelled.")
            return True

    def run_reconciliation(self):
        """Polls the exchange and reconciles internal state."""
        logging.info("--- Starting Reconciliation ---")
        
        if self.config.get("dry_run", False):
            logging.info(" Reconciliation skipped.")
            return

        exchange_open_orders_response = self.api.get_open_orders()
        if exchange_open_orders_response["error"]:
            logging.error(f"Reconciliation failed: could not fetch open orders: {exchange_open_orders_response['error']}")
            return

        exchange_open_orders = exchange_open_orders_response["result"].get("open", {})
        exchange_open_ids = set(exchange_open_orders.keys())

        internal_open_orders = {o["exchange_id"]: o for o in self.orders.values() 
                                if o.get("exchange_id") and o["status"] in}
        internal_open_ids = set(internal_open_orders.keys())

        # Discrepancy 1: Orders the engine thinks are open but exchange does not
        missing_on_exchange = internal_open_ids - exchange_open_ids
        for ex_id in missing_on_exchange:
            logging.warning(f"RECONCILIATION MISMATCH: Internal order {ex_id} is OPEN, but not found on exchange. Assuming filled/canceled.")
            internal_open_orders[ex_id]["status"] = OrderStatus.CLOSED # A safe assumption, needs more logic
        
        # Discrepancy 2: Orders the exchange thinks are open but engine does not
        orphan_on_exchange = exchange_open_ids - internal_open_ids
        for ex_id in orphan_on_exchange:
            logging.critical(f"RECONCILIATION CRITICAL: Orphan order {ex_id} found on exchange but not tracked internally!")
            # This requires manual intervention or a more complex recovery logic

        logging.info(f"--- Reconciliation Complete --- Found {len(missing_on_exchange)} missing and {len(orphan_on_exchange)} orphan orders.")


# --- Unit Tests ---

class TestExecutionEngine(unittest.TestCase):
    
    def setUp(self):
        self.mock_api = MockKrakenAPI()
        self.config = {
            "max_order_size": 100.0,
            "dry_run": False
        }
        self.engine = ExecutionEngine(self.mock_api, self.config)

    def test_01_successful_limit_order_lifecycle(self):
        """Test placing, partial filling, and cancelling a limit order."""
        # Place a limit buy order
        internal_id = self.engine.place_order(
            pair="BTC/USD", 
            side=OrderSide.BUY, 
            order_type=OrderType.LIMIT, 
            volume=20.0, 
            price=30001.0
        )
        self.assertIsNotNone(internal_id)
        order = self.engine.orders[internal_id]
        self.assertEqual(order["status"], OrderStatus.OPEN)
        exchange_id = order["exchange_id"]
        
        # Simulate a partial fill
        self.mock_api._match_order(exchange_id)
        api_order = self.mock_api.orders[exchange_id]
        self.assertEqual(api_order["status"], OrderStatus.PARTIALLY_FILLED)
        self.assertEqual(api_order["volume_executed"], 8.0) # Matched against the 8 BTC at 30001
        
        # Cancel the remainder
        cancel_success = self.engine.cancel_order(internal_id)
        self.assertTrue(cancel_success)
        self.assertEqual(self.engine.orders[internal_id]["status"], OrderStatus.CANCELED)
        self.assertEqual(self.mock_api.orders[exchange_id]["status"], OrderStatus.CANCELED)

    def test_02_idempotency_prevents_duplicate_orders(self):
        """Verify that re-sending the same order request does not create a duplicate."""
        userref = str(uuid.uuid4())
        
        # First call
        response1 = self.mock_api.add_order("BTC/USD", OrderSide.BUY, OrderType.MARKET, 1.0, userref=userref)
        self.assertFalse(response1["error"])
        order_id_1 = response1["result"]["txid"]
        
        # Second call with same userref
        response2 = self.mock_api.add_order("BTC/USD", OrderSide.BUY, OrderType.MARKET, 1.0, userref=userref)
        self.assertFalse(response2["error"])
        order_id_2 = response2["result"]["txid"]
        
        self.assertEqual(order_id_1, order_id_2)
        self.assertEqual(len([o for o in self.mock_api.orders.values() if o["userref"] == userref]), 1)
        logging.info("Idempotency test passed: Duplicate order prevented.")

    def test_03_pre_trade_risk_check_rejects_large_order(self):
        """Test that an order exceeding max_order_size is rejected internally."""
        initial_order_count = len(self.engine.orders)
        internal_id = self.engine.place_order(
            pair="BTC/USD", 
            side=OrderSide.BUY, 
            order_type=OrderType.MARKET, 
            volume=101.0 # Exceeds config limit of 100.0
        )
        self.assertIsNone(internal_id)
        self.assertEqual(len(self.engine.orders), initial_order_count)
        logging.info("Risk limit test passed: Large order rejected pre-flight.")

    def test_04_reconciliation_detects_mismatch(self):
        """Test if reconciliation finds an order that was cancelled outside the engine."""
        internal_id = self.engine.place_order("BTC/USD", OrderSide.BUY, OrderType.LIMIT, 5.0, price=29000)
        self.assertEqual(self.engine.orders[internal_id]["status"], OrderStatus.OPEN)
        exchange_id = self.engine.orders[internal_id]["exchange_id"]

        # Manually cancel the order directly in the mock API
        self.mock_api.orders[exchange_id]["status"] = OrderStatus.CANCELED
        logging.info(f"Manually set order {exchange_id} to CANCELED in mock API.")

        # Run reconciliation
        self.engine.run_reconciliation()
        
        # Check if the engine's state was corrected
        self.assertEqual(self.engine.orders[internal_id]["status"], OrderStatus.CLOSED) # Our simple logic sets it to closed
        logging.info("Reconciliation test passed: Mismatch detected and state corrected.")
        
    def test_05_dry_run_mode_logs_without_sending(self):
        """Verify dry-run mode logs actions but does not interact with the API."""
        self.engine.config["dry_run"] = True
        initial_api_order_count = len(self.mock_api.orders)
        
        with self.assertLogs(level='INFO') as cm:
            internal_id = self.engine.place_order("BTC/USD", OrderSide.BUY, OrderType.MARKET, 1.0)
            self.assertIn(" Would place order", cm.output)

        self.assertIsNotNone(internal_id)
        self.assertEqual(len(self.mock_api.orders), initial_api_order_count) # No order sent to API
        self.assertEqual(self.engine.orders[internal_id]["status"], OrderStatus.OPEN) # Status is simulated
        logging.info("Dry-run test passed: Order was logged but not sent to API.")

# --- Running the Tests ---
# In a Colab notebook or script, you can run the tests like this:
if __name__ == '__main__':
    suite = unittest.TestSuite()
    # Run tests in a specific order to make logs easier to follow
    suite.addTest(unittest.makeSuite(TestExecutionEngine, sortTestMethodsUsing=lambda x, y: x.lower() < y.lower()))
    runner = unittest.TextTestRunner()
    runner.run(suite)

